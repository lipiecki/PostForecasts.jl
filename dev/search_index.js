var documenterSearchIndex = {"docs":
[{"location":"datasets/#Datasets","page":"Datasets","title":"Datasets","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"PostForecasts.jl ships with several datasets for evaluating probabilistic forecasts, the detailed description along with the source is provided below.","category":"page"},{"location":"datasets/#EPEX-prices-on-the-German-day-ahead-energy-market","page":"Datasets","title":"EPEX - prices on the German day-ahead energy market","text":"","category":"section"},{"location":"datasets/#Data","page":"Datasets","title":"Data","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"The EPEX dataset consists of point forecasts for 24 time series of electricity prices on the German day-ahead energy market. Each time series corresponds to different hour of the day. The forecasts span a 5-year period starting from 2019. Electricy prices and data used for generating point forecats are sourced from ENTSO-E transparency platform.","category":"page"},{"location":"datasets/#LEAR-forecasts","page":"Datasets","title":"LEAR forecasts","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"Point forecasts were generated using a LASSO-Estimated AutoRegressive (LEAR) model used in (Lipiecki et al., 2024). The regressors include past prices, day-ahead predictions of the system-wide load, day-ahead RES generation, four macroeconomic variables (carbon emission prices, natural gas prices, crude oil prices and coal prices). The parameters are estimated separately for each of the 4 training window lengths, i.e., 56, 84, 1092 and 1456 most recent days and employ LASSO with cross-validation.","category":"page"},{"location":"datasets/#Loading-forecasts","page":"Datasets","title":"Loading forecasts","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"To load the forecasts from the EPEX dataset, you can use the loadDataset function. For example, to get the ForecastSeries corresponding to the first hour of the day, run:","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"fs = loaddata(:epex1)","category":"page"},{"location":"datasets/#File-example","page":"Datasets","title":"File example","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"epex_hour0.csv","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"date,price,lear56,lear84,lear1092,lear1456\n20181227,47.41,46.02598302679128,45.54356818616377,47.03463193816627,46.56173490550826\n20181228,50.04,50.618405313962285,51.29104818479025,50.82694184883733,51.254485969448226\n20181229,56.69,49.53671919852577,47.554433720562926,44.578191549767155,45.50325636133202\n...","category":"page"},{"location":"datasets/#PANGU-weather-forecasts-for-Wrocław,-Poland","page":"Datasets","title":"PANGU - weather forecasts for Wrocław, Poland","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"Forecasts from the Pangu-Weather model, computed by Bülte et al. (2024). The model is trained on 39 years of ERA5 reanalysis data from 1979–2017. The dataset consists of 5 weather variables (listed below) for Wrocław, Poland between 2018 and 2022.","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"U10: u-component of 10-m wind speed\nV10: v-component of 10-m wind speed\nT2M: temperature at 2m\nT850: temperature at 850 hPa\nZ500: geopotential height at 500 hPa.","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"One model run is initialized each day at midnight and used to forecast the variables for up to 186 hours ahead, with 6-hour resolution.","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"The dataset is partitioned into 32 files, which correspond to different forecasting horizons (lead times).","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"The verifying observations are sourced from the ERA5 reanalysis model.","category":"page"},{"location":"datasets/#Loading-forecasts-2","page":"Datasets","title":"Loading forecasts","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"To load the forecasts from the PANGU dataset, you can use the loadDataset function. For example, to get the ForecastSeries of T2M predictions with forecast horizon of 24 hours, run:","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"fs = loadDataset(:pangu24t2m)","category":"page"},{"location":"datasets/#File-example-2","page":"Datasets","title":"File example","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"pangu_lead0.csv","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"timestamp,u10_pred,v10_pred,t2m_pred,t850_pred,z500_pred,u10,v10,t2m,t850,z500\n2018010100,2.8765717,4.403717,281.96204,277.08377,54057.855,2.8765192,4.403531,281.9626,277.0831,54057.844\n2018010200,-0.12825012,3.162384,275.21405,271.42078,52858.676,-0.12847205,3.1627147,275.21313,271.42123,52858.73\n2018010300,2.0507965,1.4558716,275.82217,268.6925,52679.027,2.0507119,1.4563175,275.8231,268.69275,52679.008\n...","category":"page"},{"location":"datasets/#Acknowledgements","page":"Datasets","title":"Acknowledgements","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"We thank our collaborator Bartosz Uniejewski for LEAR foreacsts of electricity prices, and Sebastian Lerch from KIT for sharing the dataset of weather forecasts for Wrocław.","category":"page"},{"location":"averaging/#Forecast-Averaging","page":"Averaging forecasts","title":"Forecast Averaging","text":"","category":"section"},{"location":"averaging/#Averaging-schemes","page":"Averaging forecasts","title":"Averaging schemes","text":"","category":"section"},{"location":"averaging/","page":"Averaging forecasts","title":"Averaging forecasts","text":"To exploit the strong predictive performance of combining predictions from different forecasting models, PostForecasts.jl provides averaging schemes for both point and probabilistic forecasts:","category":"page"},{"location":"averaging/","page":"Averaging forecasts","title":"Averaging forecasts","text":"average\nqaverage\npaverage","category":"page"},{"location":"averaging/#PostForecasts.average","page":"Averaging forecasts","title":"PostForecasts.average","text":"average(pf; agg::Symbol=:mean)\n\nAverage the pool of point pred from pf. Return PointForecasts containing averaged forecasts, keyword argument agg specifies whether to average using simple mean (:mean) or median (:median).\n\nArgument types\n\npf::PointForecasts to average the pool of forecats in pf\npf::Vector{PointForecasts} to average all individual forecasts from every PointForecasts in pf.\n\n\n\n\n\n","category":"function"},{"location":"averaging/#PostForecasts.qaverage","page":"Averaging forecasts","title":"PostForecasts.qaverage","text":"qaverage(QF::Vector{QuantForecasts})\n\nAverage probabilistic pred from QF::Vector{QuantForecasts} by averaging quantiles of the distributions.\n\nReturn QuantForecasts containing quantile pred at the same prob as QuantForecasts stored in QF.\n\n\n\n\n\n","category":"function"},{"location":"averaging/#PostForecasts.paverage","page":"Averaging forecasts","title":"PostForecasts.paverage","text":"paverage(QF::Vector{QuantForecasts}, prob)\n\nAverage probabilistic pred from QF by averaging probabilities of the distributions.\n\nReturn QuantForecasts containing quantile pred at specified probabilities:\n\nprob::AbstractVector{<:AbstractFloat}: vector of probabilities\nprob::AbstractFloat: a single probability value\nprob::Integer: number of equidistant probability values (e.g. 99 for percentiles).\n\n\n\n\n\n","category":"function"},{"location":"models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"PostForecasts.jl provides four models for postprocessing point predictions for probabilistic forecasts: ","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Normal error distribution\nConformal prediction\nIsotonic distributional regression\nQuantile regression","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Every model belongs to the PostModel supertype. Models that work exclusively with a single point forecast as a regressor are of type UniPostModel, while models that support multiple regressors are of type MultiPostModel.","category":"page"},{"location":"models/#Normal-error-distribution","page":"Models","title":"Normal error distribution","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"The naive model for probabilistic forecasting, which assumes normally distributed errors of point forecasts. ","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The predictive distribution conditional on point forecast haty is a Gaussian mathcalN(haty + mu sigma), where mu and sigma are mean and sample standard deviation of errors in the training window.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The tau-th quantile conditional on haty of such parameterized distribution can be obtained via an analytic expression:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"hatq_tauhaty = haty + mu + sigma sqrt2 cdot texterf^-1 (2tau - 1)","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Normal\ngetmean\ngetstd","category":"page"},{"location":"models/#PostForecasts.Normal","page":"Models","title":"PostForecasts.Normal","text":"Normal([type::Type{F}=Float64]; zeromean::Bool=false) where {F<:AbstractFloat}\n\nCreates a Normal{F}<:UniPostModel{F}<:PostModel{F} model for normal error distribution. Optional keyword argument zeromean specifies wheter to assume a zero mean.\n\n\n\n\n\n","category":"type"},{"location":"models/#PostForecasts.getmean","page":"Models","title":"PostForecasts.getmean","text":"getmean(m::Normal)\n\nReturn the mean of the distribution from model m. \n\n\n\n\n\n","category":"function"},{"location":"models/#PostForecasts.getstd","page":"Models","title":"PostForecasts.getstd","text":"getstd(m::Normal)\n\nReturn the standard deviation of the distribution from model m.\n\n\n\n\n\n","category":"function"},{"location":"models/#Conformal-prediction-and-historical-simulation","page":"Models","title":"Conformal prediction and historical simulation","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Conformal prediction is a machine learning framework for computing prediction intervals based on the outputs of an arbirary point forecasting model. The implemented version of Conformal Prediction is analogous to the inductive approach used by Kath and Ziel (2021). ","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"In the training step, the non-conformity scores lambda_i are calculated on the training set (haty_i y_i)_iintexttraining window as lambda_i = haty_i - y_i.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"In the prediction step, the tau-th quantile conditional on haty_t is obtained by shifting the prediction by an appropriate empirical quantile of non-conformity scores:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"hatq_tauhaty = haty - mathbf1_tau  05 Q_1 - 2tau(lambda) + mathbf1_tau  05 Q_2tau - 1(lambda)","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"where Q_alpha(lambda) is the alpha-th empirical quantile of non-conformity scores from the training window. Although the intervals in the form of haty - Q_alpha(lambda) haty +Q_alpha(lambda) are valid alpha prediction intervals without any requirements on the underlying distribution, translating them into quantiles requires the assumption of symmetrically distributed errors.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"However, it is also possible to use conformal prediction to obtain non-symmetric distributions, by using non-absolute errors lambda_i = haty_i - y_i. Then, in the predcition step tau-th quantile conditional on haty_t is computed as:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"hatq_tauhaty = haty + Q_tau(lambda)","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"the method known as historical simulation (Nowotarski and Weron, 2018)","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"CP\ngetscores","category":"page"},{"location":"models/#PostForecasts.CP","page":"Models","title":"PostForecasts.CP","text":"CP([type::Type{F}=Float64,] n::Integer[; abs::Bool=true]) where {F<:AbstractFloat}\n\nCreates a CP{F}<:UniPostModel{F}<:PostModel{F} model for conformal prediction that stores the non-conformity scores of n observations. Optional keyword argument abs specifies wheter to use absolute errors.\n\n\n\n\n\n","category":"type"},{"location":"models/#PostForecasts.getscores","page":"Models","title":"PostForecasts.getscores","text":"getscores(m::CP)\n\nReturn a vector of non-conformity score values from model m.\n\n\n\n\n\n","category":"function"},{"location":"models/#Isotonic-distributional-regression","page":"Models","title":"Isotonic distributional regression","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Isotonic Distributional Regression (IDR; Henzi et al., 2021) has been recently introduced as a nonparametric method for estimating distributions that are isotonic in the regressed variable, which means that the quantiles of such distributions are non-decreasing w.r.t the regressor. In the training step, n observations (haty_i y_i)_i in texttraining window are first sorted to be ascending in haty_i. Then, n conditional distributions hatF_i(z) = hatF(zx_i) are obtained by solving the following min-max problem via abridged pool-adjacent-violators algorithm:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"hatF_i(z) = min_k=1i max_j=kn frac1j-k+1sum_l=k^j mathbb1y_l  z","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"where z in (y_i)_i in texttraining window To obtain conditional distribution for any hatyinmathbbR, the obtained distribution functions are interpolated","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"hatF(zhaty) = frachaty-haty_ihaty_i+1 - haty_ihatF_i(z) + frachaty_i+1 - hatyhaty_i+1 - haty_i hatF_i+1(z)","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"If haty  haty_1 or haty  haty_n, we set hatF(zhaty) to hatF_1(z) or hatF_n(z), respectively. Finally, since ProbcastSeries stores predictive distributions in the form of quantiles, we determine quantiles at specified levels as","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"hatq_tauhaty = minz  hatF(zhaty) geq tau","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The multivariate version of IDR is not supported, but ForecastSeries containing multiple forecasts can be used as input for computing ProbcastSeries. In such a case, multiple univariate IDR models are estimated and the resulting distributions functions hatF(z) are averaged. Since z is limited to true values of the timeseries in training window, the distributions resulting from estimated IDRs are defined at the exact same points, which allows to efficiently and precisely compute the average across probability. ","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The implemented IDR estimation uses abridged pool-adjacent-violators algorithm introduced by Henzi et al. (2022)","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"IDR\ngetcdf\ngetx\ngety","category":"page"},{"location":"models/#PostForecasts.IDR","page":"Models","title":"PostForecasts.IDR","text":"IDR([type::Type{F}=Float64,] n::Integer, r::Integer) where {F<:AbstractFloat}\n\nCreates an IDR{F}<:MultiPostModel{F}<:PostModel{F} model for isotonic distributional regression to be trained on n observations with r forecasts (regressors).\n\n\n\n\n\n","category":"type"},{"location":"models/#PostForecasts.getcdf","page":"Models","title":"PostForecasts.getcdf","text":"getcdf(m::IDR [, r])\n\nReturn a vector of cumulative distribution function values from model m. Optional argument r::Integer = 1 corresponds to the regressor index.\n\n\n\n\n\n","category":"function"},{"location":"models/#PostForecasts.getx","page":"Models","title":"PostForecasts.getx","text":"getx(m::IDR [, r])\n\nReturn a vector of regressor values from model m on which cumulative dsitribution function is defined. Optional argument r::Integer = 1 corresponds to the regressor index.\n\n\n\n\n\n","category":"function"},{"location":"models/#PostForecasts.gety","page":"Models","title":"PostForecasts.gety","text":"gety(m::IDR)\n\nReturn a vector of response values from model m on which cumulative dsitribution function is defined.\n\n\n\n\n\n","category":"function"},{"location":"models/#Quantile-regression","page":"Models","title":"Quantile regression","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Quantile Regression Averaging (QRA; Nowotarski and Weron, 2014) is a well-established method in for obtaining probabilistic forecasts of electricity prices and load. It learns conditional quantiles as linear combination of m point forecasts:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"hatq_tauhaty^(1)  haty^(m) = beta^(tau)_0 + beta^(tau)_1haty^(1) +  + beta^(tau)_mhaty^(m)","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The coefficients beta^(tau)_0m are selected to minimize the pinball loss on the training window and estimated by solving a linear programming problem. For this task, Probcasts.jl employs JuMP.jl and HiGHS.jl packages. Different LP solvers compatible with JuMP can be used, but the constructor defaults to an open source HiGHS.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Apart from the standard QRA introduced by Nowotarski and Weron (2014), PostForecasts.jl allows to readily compute Quantile Regression Machine (QRM; Marcjasz et al., 2020) and Quantile Regression with probability (F) or Quantile averaging [(QRF or QRQ; Uniejewski et al., 2019)][https://doi.org/10.1016/j.eneco.2018.02.007]. See Different flavors of quantile regression for details.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"QR\ngetweights\ngetquantprob","category":"page"},{"location":"models/#PostForecasts.QR","page":"Models","title":"PostForecasts.QR","text":"QR([type::Type{F}=Float64,] n::Integer, r::Integer, prob::Union{AbstractFloat, Vector{<:AbstractFloat}}) where {F<:AbstractFloat}\n\nCreates a QR{F}<:MultiPostModel{F}<:PostModel{F} model for quantile regression to be trained on n observations with r forecasts (regressors), fitting quantiles at probabilties specified by prob.\n\n\n\n\n\n","category":"type"},{"location":"models/#PostForecasts.getweights","page":"Models","title":"PostForecasts.getweights","text":"getweights(m::QR)\n\nReturn a copy of the weight matrix from model m.\n\n\n\n\n\n","category":"function"},{"location":"models/#PostForecasts.getquantprob","page":"Models","title":"PostForecasts.getquantprob","text":"getquantprob(m::QR) Return a vector of probabilities corresponding to the quantiles from model m.\n\n\n\n\n\n","category":"function"},{"location":"models/#Training-and-prediction","page":"Models","title":"Training and prediction","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"train\npredict\npredict!","category":"page"},{"location":"models/#PostForecasts.train","page":"Models","title":"PostForecasts.train","text":"train(m, X, Y)\n\nCalibrate the model m on the covariates X and responses Y.\n\nIn general, X should be a matrix, which columns correspond to respective regressors. The number of regressors must match the specification of the model.\n\nFor m::UniPostModel, X can be a vector, if it is a matrix with multiple columns, they will be averaged before training.\n\n\n\n\n\n","category":"function"},{"location":"models/#PostForecasts.predict","page":"Models","title":"PostForecasts.predict","text":"predict(m, input, prob)\n\nPredict quantiles at specified probabilbities using model m::PostModel{F} with input.\n\nArgument types\n\ninput can be of type Number or AbstractVector{<:Number}\nprob can be of type AbstractFloat (to return F) or AbstractVector{<:AbstractFloat} (to return Vector{F})\n\nNote\n\nFor m::QR, prob argument can be ommited in the function call to return all quantiles specified in model m.\n\n\n\n\n\n","category":"function"},{"location":"models/#PostForecasts.predict!","page":"Models","title":"PostForecasts.predict!","text":"predict!(m, output, input, prob)\n\nIn-place version of predict that stores the results in the output::AbstractVector{<:AbstractFloat} vector.\n\nArgument types\n\ninput can be of type Number or AbstractVector{<:Number}\nprob needs to be of type AbstractVector{<:AbstractFloat}\n\nNote\n\nFor m::QR, prob argument will be ignored and can be ommited in the function call.\n\n\n\n\n\n","category":"function"},{"location":"utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"A place to store useful functions that didn't fit elsewhere","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"getmodel\nnreg\nmatchwindow\ncheckmatch","category":"page"},{"location":"utils/#PostForecasts.getmodel","page":"Utilities","title":"PostForecasts.getmodel","text":"getmodel([::Type{<:AbstractFloat}=Float64,] ::Val, params...)\n\nHelper function that dispatches the model based on the model name passed as Val.\n\nAvailable methods\n\ngetmodel([type,] Val(:qra), n, m, prob) for Quantile Regression Averaging\ngetmodel([type,] Val(:cp), n) for Conformal Prediction\ngetmodel([type,] Val(:hs), n) for Conformal Prediction Prediction with non-symmetric errors (a.k.a. Historical Simulation)\ngetmodel([type,] Val(:idr), n, m) for Isotonic Distributional Regression\ngetmodel([type,] Val(:normal)) for Normal distribution of errors\ngetmodel([type,] Val(:zeronormal)) for Normal distribution of errors with fixed mean equal to 0\n\nwhere n is the length of the training window, m is the number of regressors and prob is the probability (scalar value or vector).\n\nReturn an appropriate PostModel.\n\n\n\n\n\n","category":"function"},{"location":"utils/#PostForecasts.nreg","page":"Utilities","title":"PostForecasts.nreg","text":"nreg(m::PostModel)\n\nReturn the number of regressors of model m.\n\n\n\n\n\n","category":"function"},{"location":"utils/#PostForecasts.matchwindow","page":"Utilities","title":"PostForecasts.matchwindow","text":"matchwindow(m::PostModel, window::Integer)\n\nReturn true if window matches the specification of model m, otherwise return false.\n\n\n\n\n\n","category":"function"},{"location":"utils/#PostForecasts.checkmatch","page":"Utilities","title":"PostForecasts.checkmatch","text":"chechmatch(S::AbstractVector{<:ForecastSeries}; checkpred::Bool=false)\n\nCheck if PointForecasts or QuantForecasts provided in vector S match, i.e.:\n\nall their identifiers match\nall their observations match\ntheir number of forecasts match (if checkpred=true)\ntheir probabilities match (for QuantForecasts if checkpred=true).\n\nReturn nothing, throw an ArgumentError if any of the requirements above is not met.\n\n\n\n\n\n","category":"function"},{"location":"forecasts/#Forecasts-structures","page":"Structures","title":"Forecasts structures","text":"","category":"section"},{"location":"forecasts/","page":"Structures","title":"Structures","text":"To make working with forecasts easy and user-friendy, PostForecasts.jl introduces Forecasts type, a supertype that spans PointForecasts and QuantForecast structures.","category":"page"},{"location":"forecasts/#PointForecasts","page":"Structures","title":"PointForecasts","text":"","category":"section"},{"location":"forecasts/","page":"Structures","title":"Structures","text":"PointForecasts is a structure designed for storing the series of point predictions (single predictions or prediction pools), along with the observations and identifiers (timestamps). The package provides functions for building PointForecasts objects from delimited files, calculating error measures (MAE and RMSE) and averaging point pred.","category":"page"},{"location":"forecasts/#QuantForecasts","page":"Structures","title":"QuantForecasts","text":"","category":"section"},{"location":"forecasts/","page":"Structures","title":"Structures","text":"QuantForecasts is a structure designed for storing the series of probabilistic predictions, represented as quantiles of predictive distribution corresponding to probability levels, along with the observations and identifiers (timestamps). The package provides functions for computing probabilstic forecasts from PointForecasts objects, calculating pinball loss and averaging distributions across quantiles or probabilities.","category":"page"},{"location":"forecasts/#Position-based-indexing-and-slicing","page":"Structures","title":"Position-based indexing and slicing","text":"","category":"section"},{"location":"forecasts/","page":"Structures","title":"Structures","text":"PointForecasts and QuantForecasts support position-based indexing and slicing. Accessing a series with a scalar index results in a named tuple, while slicing creates a new Forecasts object built from pred, observations and identifiers stored at respective indices.","category":"page"},{"location":"forecasts/","page":"Structures","title":"Structures","text":"pf = loaddata(:epex1);\nfirstday = pf[1]\n#(pred = [27.640966097698737, 24.423563275081627, 23.54144377224293, 25.061033846927558], obs = 10.07, id = 20190101)\nfirstweek = pf[1:7]\n#PointForecasts{Float64, Int64} with a pool of 4 forecasts at 7 timesteps, between 20190101 and 20190107","category":"page"},{"location":"forecasts/#Label-based-indexing-and-slicing","page":"Structures","title":"Label-based indexing and slicing","text":"","category":"section"},{"location":"forecasts/","page":"Structures","title":"Structures","text":"Since PointForecasts and QuantForecasts structures have id field storing an integer identifier for every timestep, it is posibble to access the elements by providng their identifier values. Use () for label-based indexing and slicing. Analogously to positional indices, providing a single label results in a named tuple, while a vector creates a new Forecasts object. Additionally, you can provide two labels, (id1, id2), to return Forecasts starting at the timestep with identifier id1 and ending at the timestep with identifier id2.","category":"page"},{"location":"forecasts/","page":"Structures","title":"Structures","text":"pf = loaddata(:epex1);\nfirstday = pf(20190101)\n#(pred = [27.640966097698737, 24.423563275081627, 23.54144377224293, 25.061033846927558], obs = 10.07, id = 20190101)\nfirstweek = pf([20190101, 20190102, 20190103, 20190104, 20190105, 20190106, 20190107])\n#PointForecasts{Float64, Int64} with a pool of 4 forecasts at 7 timesteps, between 20190101 and 20190107\nfirstweek2 = pf(20190101, 20190107) # same as `firstweek`\n#PointForecasts{Float64, Int64} with a pool of 4 forecasts at 7 timesteps, between 20190101 and 20190107","category":"page"},{"location":"forecasts/","page":"Structures","title":"Structures","text":"PointForecasts\nQuantForecasts\nfindindex\ndecouple\nnpred\nsetpred\ngetpred\ngetobs\ngetid\ngetprob\nviewpred\nviewobs\nviewid\nviewprob","category":"page"},{"location":"forecasts/#PostForecasts.PointForecasts","page":"Structures","title":"PostForecasts.PointForecasts","text":"PointForecasts(pred::AbstractVecOrMat{F}, obs::AbstractVector{F}[, id::AbstractVector{I}]) where {F<:AbstractFloat, I<:Integer}\n\nCreate PointForecasts{F, I} for storing the series of point predictions, along with the observations and identifiers.\n\nThe shape of pred should be such that pred[t, i] is the prediction for time t from the forecaster i.\n\nIf id is not provided, it will default to 1:length(obs).\n\n\n\n\n\n","category":"type"},{"location":"forecasts/#PostForecasts.QuantForecasts","page":"Structures","title":"PostForecasts.QuantForecasts","text":"QuantForecasts(pred::AbstractMatrix{F}, obs::AbstractVector{F}[, id::AbstractVector{I}, prob::Union{F, AbstractVector{F}}]) where {F<:AbstractFloat, I<:Integer}\n\nCreate QuantForecasts{F, I} for storing the series of probabilistic predictions, represented as quantiles of predictive distribution at specfied probabilities, along with the observations and identifiers.\n\nThe shape of pred should be such that pred[t, i] is the prediction for time t of the prob[i]-quantile.\n\nIf id is not provided, it will default to 1:length(obs). If prob is not provided, it will default to size(pred, 2) equidistant quantiles.\n\n\n\n\n\n","category":"type"},{"location":"forecasts/#PostForecasts.findindex","page":"Structures","title":"PostForecasts.findindex","text":"findindex(fs::Forecasts, i::Integer)\n\nReturn the index of fs, for which the element of field id equals i.\n\n\n\n\n\n","category":"function"},{"location":"forecasts/#PostForecasts.decouple","page":"Structures","title":"PostForecasts.decouple","text":"decouple(pf::PointForecasts)\n\nReturn ::Vector{PointForecasts}, where each element contains an individual forecast series from pf.\n\n\n\n\n\n","category":"function"},{"location":"forecasts/#PostForecasts.npred","page":"Structures","title":"PostForecasts.npred","text":"npred(fs::Forecasts)\n\nReturn the number of point forecasts in fs::PointForecasts or the number of forecasted quantiles in fs::QuantForecasts.\n\n\n\n\n\n","category":"function"},{"location":"forecasts/#PostForecasts.setpred","page":"Structures","title":"PostForecasts.setpred","text":"setpred(fs::Forecasts, t::Integer, i::Integer, val::AbstractFloat)\n\nSet the element of field fs.pred at indices t, i to val.\n\n\n\n\n\n","category":"function"},{"location":"forecasts/#PostForecasts.getpred","page":"Structures","title":"PostForecasts.getpred","text":"getpred(fs::Forecasts[, T, I])\n\nReturn the copy of predictions from fs. \n\nProvide optional argument T::Union{Integer, AbstractVector{<:Integer}} to get predictions at specified time indices.\n\nAdditionally, provide I::Union{Integer, AbstractVector{<:Integer}} to get predicitons at specified forecast indices.\n\n\n\n\n\n","category":"function"},{"location":"forecasts/#PostForecasts.getobs","page":"Structures","title":"PostForecasts.getobs","text":"getobs(fs::Forecasts[, T])\n\nReturn the copy of observations from fs. \n\nProvide optional argument T::Union{Integer, AbstractVector{<:Integer}} to get observations at specified time indices.\n\n\n\n\n\n","category":"function"},{"location":"forecasts/#PostForecasts.getid","page":"Structures","title":"PostForecasts.getid","text":"getid(fs::Forecasts[, T])\n\nReturn the copy of identifiers from fs. \n\nProvide optional argument T::Union{Integer, AbstractVector{<:Integer}} to get identifiers at specified time indices.\n\n\n\n\n\n","category":"function"},{"location":"forecasts/#PostForecasts.getprob","page":"Structures","title":"PostForecasts.getprob","text":"getprob(qf::QuantForecasts[, I])\n\nReturn the copy of probabilities from qf. \n\nProvide optional argument I::Union{Integer, AbstractVector{<:Integer}} to get probabilities at specified forecast indices.\n\n\n\n\n\n","category":"function"},{"location":"forecasts/#PostForecasts.viewpred","page":"Structures","title":"PostForecasts.viewpred","text":"viewpred(fs::Forecasts[, T, I])\n\nReturn the view of predictions from fs. \n\nProvide optional argument T::Union{Integer, AbstractVector{<:Integer}} to get predictions at specified time indices.\n\nAdditionally, provide I::Union{Integer, AbstractVector{<:Integer}} to get predicitons at specified forecast indices.\n\n\n\n\n\n","category":"function"},{"location":"forecasts/#PostForecasts.viewobs","page":"Structures","title":"PostForecasts.viewobs","text":"viewobs(fs::Forecasts[, T])\n\nReturn the view of observations from fs. \n\nProvide optional argument T::Union{Integer, AbstractVector{<:Integer}} to get observations at specified time indices.\n\n\n\n\n\n","category":"function"},{"location":"forecasts/#PostForecasts.viewid","page":"Structures","title":"PostForecasts.viewid","text":"viewid(fs::Forecasts[, T])\n\nReturn the view of identifiers from fs. \n\nProvide optional argument T::Union{Integer, AbstractVector{<:Integer}} to get identifiers at specified time indices.\n\n\n\n\n\n","category":"function"},{"location":"forecasts/#PostForecasts.viewprob","page":"Structures","title":"PostForecasts.viewprob","text":"viewprob(qf::QuantForecasts[, I])\n\nReturn the view of probabilities from qf. \n\nProvide optional argument I::Union{Integer, AbstractVector{<:Integer}} to get probabilities at specified forecast indices.\n\n\n\n\n\n","category":"function"},{"location":"loadsave/#Loading-and-saving-forecasts","page":"Loading and saving forecasts","title":"Loading and saving forecasts","text":"","category":"section"},{"location":"loadsave/","page":"Loading and saving forecasts","title":"Loading and saving forecasts","text":"With PostForecasts.jl You can easily create PointForecasts from delimited files, load and save both PointForecasts and QuantForecast using HDF5 format and play with pre-installed datasets.","category":"page"},{"location":"loadsave/","page":"Loading and saving forecasts","title":"Loading and saving forecasts","text":"To make managing files generated with PostForecasts.jl easier, HDF5 files containing PointForecasts and QuantForecasts are saved with .pointf and .quantf extensions respectively.","category":"page"},{"location":"loadsave/","page":"Loading and saving forecasts","title":"Loading and saving forecasts","text":"loaddata\nloaddlmdata\nsave\nloadpointf\nloadquantf","category":"page"},{"location":"loadsave/#PostForecasts.loaddata","page":"Loading and saving forecasts","title":"PostForecasts.loaddata","text":"loaddata(dataset::Symbol)\n\nCreate a PointForecasts object from the dataset provided with the package, availabe options include:\n\n:epexH, where H is an integer between 1 and 24\n:pangu'H'u10, where H is an integer between 0 and 186, divisible by 6.\n:pangu'H'v10, where H is an integer between 0 and 186, divisible by 6.\n:pangu'H't2m, where H is an integer between 0 and 186, divisible by 6.\n:pangu'H't850, where H is an integer between 0 and 186, divisible by 6.\n:pangu'H'z500, where H is an integer between 0 and 186, divisible by 6.\n\nDetails of the datasets are avaiable in documentation.\n\n\n\n\n\n","category":"function"},{"location":"loadsave/#PostForecasts.loaddlmdata","page":"Loading and saving forecasts","title":"PostForecasts.loaddlmdata","text":"loaddlmdata(filepath::String; kwargs...)\n\nCreate a PointForecasts object from delimited file at filepath.\n\nKeyword Arguments\n\ndelim=',': Specifies the delimitter\nidcol=1: Specifies which column is used for timestamps (0 to generate timestamps automatically)\nobscol=2: Specifies which column is used for observations\npredcol=0: Specifies which columns are used for pred (0 to use all remaining columns)\ncolnames=false If true, omit the first row of the file.\n\n\n\n\n\n","category":"function"},{"location":"loadsave/#PostForecasts.save","page":"Loading and saving forecasts","title":"PostForecasts.save","text":"save(f::Forecasts, filepath::String, groupname::String=\"forecasts\")\n\nSave f to a HDF5 file at filepath (.pointf or .quantf extension is added if missing). Optionally specify the name of the group, in which the data will be saved. \n\n\n\n\n\n","category":"function"},{"location":"loadsave/#PostForecasts.loadpointf","page":"Loading and saving forecasts","title":"PostForecasts.loadpointf","text":"loadpointf(filepath::String, groupname::String=\"forecasts\")\n\nLoad PointForecasts from a HDF5 file at filepath (.pointf extension is added if missing). Optionally specify the name of the group, from which the data will be loaded.\n\n\n\n\n\n","category":"function"},{"location":"loadsave/#PostForecasts.loadquantf","page":"Loading and saving forecasts","title":"PostForecasts.loadquantf","text":"loadquantf(filepath::String, groupname::String=\"forecasts\")\n\nLoad QuantForecasts from a HDF5 file at filepath (.quantf extension is added if missing). Optionally specify the name of the group, from which the data will be loaded.\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Below You can find some simple examples of what can be achieved with PostForecasts.jl","category":"page"},{"location":"examples/#Electricity-price-forecasting","page":"Examples","title":"Electricity price forecasting","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example showcases how to prepare probabilistic forecasts of day-ahead electricity prices for all 24 hours, using three different models (IDR, CP and QRA), for a specified calendar year.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"First, specify the year (between 2019 and 2023) and the length of the training window (note that data starts at the begining of 2019). Here we use the year 2021 and a 182-day window.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using PostForecasts, Statistics\n\nyear = 2021\nwindow = 182\nmodels = [:idr, :cp, :qr]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Prepare a dictionary for storing pinball loss values for each model and hour.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"losses = Dict((model => zeros(24) for model in models)...)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Then, for each hour load the point forecasts as fs::ForecastSeries and find the indices corresponidng to the first and last day of the specified year. Generate the probabilistic forecasts at 9 equidistant probability levels (fourth argument of point2quant) using each model and save their pinball losses.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Threads.@threads for hour in 1:24\n    pf = loaddata(Symbol(:epex, hour))\n    first = findindex(pf, year*10_000 + 0101)\n    last = findindex(pf, year*10_000 + 1231)\n    for model in models\n        losses[model][hour] = mean(pinball(point2quant(pf, model, window, 9, first=first, last=last)))\n    end\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here, Threads.@threads is used to parallelize over available threads. Use julia --threads=X to run a Julia instance with X threads.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Print the results","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"println(\"Year: $(year)\")\nprintln(\"Calibration window of $(window) days\")\nprintln(\"-\"^30)\nprintln(\"Model\\t| Average Pinball Loss\")\nprintln(\"-\"^30)\nfor model in models\n    println(uppercase(string(model)), \"\\t|\", round(mean(losses[model]), digits=3))\nend\nprintln(\"-\"^30)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This script (examples/epf.jl) should yield the following output:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Year: 2021\nCalibration window of 182 days\n------------------------------\nModel\t| Average Pinball Loss\n------------------------------\nIDR\t|4.831\nCP\t|4.859\nQR\t|4.768\n------------------------------","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note that the computation may take some time. While IDR and CP are almost instantaneous, QRA is more time-consuming and can take several minutes if run on a single thread.","category":"page"},{"location":"examples/#Different-flavors-of-quantile-regression","page":"Examples","title":"Different flavors of quantile regression","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"There are multiple approaches to applying quantile regression to a pool of point forecasts, here we compare four of them, which can be readily computed using the PostForecasts.jl package.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"First, specify the training window, the number of quantiles to be forecasted and the data to be used for postprocessing:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using PostForecasts\n\nyear = 2021\nwindow = 182\nnquantiles = 9\nhour = 15\n\npf = loaddata(Symbol(:epex, hour))\nfirst = findindex(pf, year*10_000 + 0101)\nlast = findindex(pf, year*10_000 + 1231)\npf = pf[first-window:last]","category":"page"},{"location":"examples/#QRA","page":"Examples","title":"QRA","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Quantile Regression Averaging - each point forecast is treated as a seperate regressor in a multivariate quantile regression - hatq_tauhaty^(1)  haty^(m) = beta^(tau)_0 + beta^(tau)_1haty^(1) +  + beta^(tau)_mhaty^(m)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"qfQRA = point2quant(pf, :qr, window, nquantiles)","category":"page"},{"location":"examples/#QRM","page":"Examples","title":"QRM","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Quantile Regression Machine - point forecasts are averaged and treated as a single regressor in a univariate quantile regression - hatq_tauhaty^(1)  haty^(m) = beta^(tau)_0 + beta^(tau)_1 frac1msum_i=1^mhaty^(i)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"qfQRM = point2quant(average(pf), :qr, window, nquantiles)","category":"page"},{"location":"examples/#QRF","page":"Examples","title":"QRF","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Quantile Regression with probability (F) averaging - each point forecast is treated as a regressor of a univariate quantile regression, the output distributions of m quantile regressions are averaged over probabilities","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"qfQRF = paverage([point2quant(ipf, :qr, window, nquantiles) for ipf in decouple(pf)], nquantiles)","category":"page"},{"location":"examples/#QRQ","page":"Examples","title":"QRQ","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Quantile Regression with Quantile averaging - each point forecast is treated as a regressor of a univariate quantile regression, the output distributions of m quantile regressions are averaged over quantiles","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"qfQRQ = qaverage([point2quant(ipf, :qr, window, nquantiles) for ipf in decouple(pf)])","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Print the results of the models","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"println(\"Year $(year), hour $(hour-1):00\")\nprintln(\"Calibration window of $(window) days\")\nprintln(\"-\"^30)\nprintln(\"Model\\t| Average Pinball Loss\")\nprintln(\"-\"^30)\nprintln(\"QRA\\t|\", round(mean(pinball(qfQRA)), digits=3))\nprintln(\"QRM\\t|\", round(mean(pinball(qfQRM)), digits=3))\nprintln(\"QRF\\t|\", round(mean(pinball(qfQRQ)), digits=3))\nprintln(\"QRQ\\t|\", round(mean(pinball(qfQRF)), digits=3))\nprintln(\"-\"^30)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The expected output of this script (examples/quantregs.jl):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Year 2021, hour 14:00\nCalibration window of 182 days\n------------------------------\nModel\t| Average Pinball Loss\n------------------------------\nQRA\t|5.61\nQRM\t|5.449\nQRF\t|5.296\nQRQ\t|5.365\n------------------------------","category":"page"},{"location":"examples/#Conformalizing-weather-forecasts","page":"Examples","title":"Conformalizing weather forecasts","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Specify which weather variable to forecast and at which lead time to use.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using PostForecasts\n\nvariable = :u10 # u10, c10, t2m, t850 or z500\nleadtime = 24 # between 0 and 186, divisible by 6\n\npf = loaddata(Symbol(:pangu, leadtime, variable))\nprintln(\"$(uppercase(string(variable))) forecasts with lead time of $(leadtime) hours\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Compute the quantile forecasts (9 quantiles at equidistant probabilities) using IDR with a training window of a single year.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"qf = point2quant(fs, :idr, 364, 9)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Print the coverage of ps.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"println(\"\\t\", \"-\"^73)\nprintln(\"\\t| \\t\\t\\t Coverage of α-quantiles \\t\\t\\t|\")\nprintln(\"-\"^81)\nprintln(\"Model\\t| α=0.1\\t| α=0.2\\t| α=0.3\\t| α=0.4\\t| α=0.5\\t| α=0.6\\t| α=0.7\\t| α=0.8\\t| α=0.9\\t|\")\nprintln(\"-\"^81)\nprint(\"IDR\\t|\")\nfor cov in coverage(qf)\n    print(\" \", round(cov, digits=3), \"\\t|\")\nend\nprintln()","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Conformalize the quanitle forecasts qf, with 182-day training window. Note that the in-place method confomalize! will leave the first 182 unmodified predictions in the qf. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"conformalize!(qf, 182)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Print the coverage of conformalized qf.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"println(\"-\"^81)\nprint(\"CIDR\\t|\")\nfor cov in coverage(qf)\n    print(\" \", round(cov, digits=3), \"\\t|\")\nend\nprintln()\nprintln(\"-\"^81)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The output of this script (examples/weather.jl) should be the following","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"U10 forecasts with lead time of 24 hours\n        -------------------------------------------------------------------------\n        |                        Coverage of α-quantiles                        |\n---------------------------------------------------------------------------------\nModel   | α=0.1 | α=0.2 | α=0.3 | α=0.4 | α=0.5 | α=0.6 | α=0.7 | α=0.8 | α=0.9 |\n---------------------------------------------------------------------------------\nIDR     | 0.157 | 0.238 | 0.322 | 0.42  | 0.493 | 0.59  | 0.681 | 0.762 | 0.85  |\n---------------------------------------------------------------------------------\nCIDR    | 0.106 | 0.204 | 0.309 | 0.411 | 0.501 | 0.596 | 0.71  | 0.795 | 0.897 |\n---------------------------------------------------------------------------------","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"which shows that the conformalization indeed helps to decrease the miscoverage of IDR predictions, especially at more extreme quantiles (0.1 and 0.9).","category":"page"},{"location":"examples/#Supporting-decision-making-on-energy-markets","page":"Examples","title":"Supporting decision making on energy markets","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"To highlight the significance and utility of probabilsitic forecasts, let us present a short scenario of trading on day-ahead electricity market.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Imagine that we have battery at our disposal, and for simplicity assume that each day we can buy and sell energy only at specifc hours, e.g. buy at 3:00 and sell at 19:00 (trading hours from a strategy used by Marcjasz et al. (2023)). Therefore, everyday we face the decision about whether to submit buy and sell orders for the next day, or avoid trading. Forecasts of day-ahead prices can support this decision-making process.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"As an example, we will focus on two weeks in April 2023. Firstly, we will postprocess point predictions to obtain quantile forecasts using IDR","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using PostForecasts, Plots\n\nfirstdate = 20230408\nlastdate = 20230421\n\nbuyhour = 4     # 3:00\nsellhour = 20   # 19:00\n\nfsBUY = loaddata(Symbol(:epex, buyhour))\nfsSELL = loaddata(Symbol(:epex, sellhour))\n\nfirst= findindex(fsBUY, firstdate)\nlast = findindex(fsBUY, lastdate)\n\nqfBUY = point2quant(fsBUY, :idr, 182, 9, first=first, last=last)\nqfSELL = point2quant(fsSELL, :idr, 182, 9, first=first, last=last)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let us see what we can learn from the forecasts of median price:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"theme(:dark)\nplot(legend = :bottom, xlabel = \"Days\", ylabel = \"Price (€/MWh)\", xticks = 1:14, framestyle = :box)\nplot!(viewpred(qfBUY, eachindex(qfBUY), 5), linealpha = 0.5, color=3, lw=3, label=\"Buy hour ($(buyhour):00)\")\nplot!(viewpred(qfSELL, eachindex(qfBUY), 5), linealpha = 0.5, color=1, lw=3, label=\"Sell hour ($(sellhour):00)\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: image) Analyzing the above plot, every day seems to be profitable, but the information is quite limited. To make an informed decision, we would like to see what can happens in more extreme scenarios. Since we computed 9 deciles, we can plot 4 prediction intervals centered around the median (with confidence of 20%, 40%, 60% and 80%):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"for i in 1:4\n    plot!(viewpred(qfBUY, eachindex(qfBUY), 5-i), lw = 0, fillrange = viewpred(qfBUY, eachindex(qfBUY), 5+i), fillalpha = 0.1, color = 3, label = nothing)\n    plot!(viewpred(qfSELL, eachindex(qfBUY), 5-i), lw = 0, fillrange = viewpred(qfSELL, eachindex(qfBUY), 5+i), fillalpha = 0.1, color = 1, label = nothing)    \nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: image)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we see that on the 3rd day, the upper quantiles of prices at 3:00 significantly overlap the lower quantiles of prices at 19:00. Depending on our risk appetite, we could refrain from trading during this day to avoid possible losses.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Finally, let's add the observed prices during this period:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plot!(viewobs(qfBUY), color = 3, st=:scatter, markerstrokewidth=0, label=nothing)\nplot!(viewobs(qfSELL), color = 1, st=:scatter, markerstrokewidth=0, label=nothing)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: image)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Indeed, on the 3rd day the decision to avoid traiding would prevent us from incurring a loss. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This short example was cherry-picked to showcase how probabilistic foreecasts provide us with more information about possible outcomes of decisions. To read about the strategies for battery-based trading on electricity markets and their economic evaluation, see the contributions of Nitka and Weron (2023) and Maciejowska et al. (2023).","category":"page"},{"location":"shapley/#Shapley-values-and-ensemble-contributions","page":"Shapley values and ensemble contributions","title":"Shapley values and ensemble contributions","text":"","category":"section"},{"location":"shapley/","page":"Shapley values and ensemble contributions","title":"Shapley values and ensemble contributions","text":"When averaging multiple predicitons, a question arises of what each forecaster brings to the table. To answer that, we propose to use Shapley values, following machine learning methods like SHapley Additive exPlanations (SHAP; Lundberg and Lee, 2017), Loss SHapley Additive exPlanations (LossSHAP; Lundberg et al., 2020) and Shapley Additive Global importancE (SAGE; Covert et al., 2020). Shapley values were originally developed to fairly distribute total wins (rightarrow predictive power) among players (rightarrow ensemble components) in a cooperative game based on their individual contributions. In our approach, we consider a coalition game v_x(S), defined as","category":"page"},{"location":"shapley/","page":"Shapley values and ensemble contributions","title":"Shapley values and ensemble contributions","text":"v_x(S) = -L(textAve_x(S) x)","category":"page"},{"location":"shapley/","page":"Shapley values and ensemble contributions","title":"Shapley values and ensemble contributions","text":"where S is a non-empty subset of forecasters (players), L is a loss function and textAve_x(S) is the prediction of x obtained by averaging forecasts from S. Shapley values for the game v_x(S) are analogous to LossSHAP of model textAve_x(S), while their mean over a testing period is a counterpart of SAGE. However, we consider simple averaging methods for which marginal contributions can be calculated directly, without resorting to approximation algorithms required by SHAP, LossSHAP and SAGE.","category":"page"},{"location":"shapley/","page":"Shapley values and ensemble contributions","title":"Shapley values and ensemble contributions","text":"For the game v_x(S) and a set of N players (forecasters), Shapley value phi_i of forecaster i is given by","category":"page"},{"location":"shapley/","page":"Shapley values and ensemble contributions","title":"Shapley values and ensemble contributions","text":"phi_i = frac1N sum_S in P(N backslash i) binomN-1S^-1leftv_x(S cup i) - v_x(S)right","category":"page"},{"location":"shapley/","page":"Shapley values and ensemble contributions","title":"Shapley values and ensemble contributions","text":"The sum above extends over the entire powerset P(N backslash i), including the empty set varnothing. Let us diverge from this standard definition by omitting the empty coalition and defining Shapley values Phi_i as","category":"page"},{"location":"shapley/","page":"Shapley values and ensemble contributions","title":"Shapley values and ensemble contributions","text":"Phi_i = frac1Nsum_S in P(N backslash i)backslashvarnothing binomN-1S^-1leftv_x(S cup i) - v_x(S)right","category":"page"},{"location":"shapley/","page":"Shapley values and ensemble contributions","title":"Shapley values and ensemble contributions","text":"As a result, Phi discounts the accuracy of individual forecasters, i.e. Phi_i = phi_i - frac1N(v_x(i) - v_x(varnothing)) and the obtained Shapley values sum up to the accuracy gained from averaging, i.e. the difference between the accuracy of the ensemble average and the average accuracy of individual ensemble components:","category":"page"},{"location":"shapley/","page":"Shapley values and ensemble contributions","title":"Shapley values and ensemble contributions","text":"sum_iin NPhi_i = v_x(N) - frac1Nsum_i in Nv_x(i)","category":"page"},{"location":"shapley/","page":"Shapley values and ensemble contributions","title":"Shapley values and ensemble contributions","text":"Although Phi differ from standard Shapley values, they remain to be a fair allocation, in a sense that Phi_i  Phi_j iff v_x(i)  v_x(j) for N=ij. Furthermore, the properties of symmetry, linearity and null-player also hold for Shapley values Phi.","category":"page"},{"location":"shapley/","page":"Shapley values and ensemble contributions","title":"Shapley values and ensemble contributions","text":"PostForecasts.jl provides shapley function that allows to calculate Shapley values for both point and probabilstic forecats using arbitrary averaging method and payoff function. Returned values are averages over the forecasted period.","category":"page"},{"location":"shapley/","page":"Shapley values and ensemble contributions","title":"Shapley values and ensemble contributions","text":"shapley","category":"page"},{"location":"shapley/#PostForecasts.shapley","page":"Shapley values and ensemble contributions","title":"PostForecasts.shapley","text":"shapley(FS::Vector{<:Forecasts{F, I}}, agg::Function, payoff::Function[, null_payoff::AbstractFloat])\n\nCalculate Shapley values of forecasters in FS, using specified aggregation function and payoff function.\n\nOptional argument null_payoff is the payoff value for an empty coalition. If not provided, empty coalition is excluded from calculations.\n\nReturn a vector of Shapley values correspinding to each forecaster in FS.\n\n\n\n\n\n","category":"function"},{"location":"shapley/","page":"Shapley values and ensemble contributions","title":"Shapley values and ensemble contributions","text":"The function agg passed to shapley should be of the signature ::Vector{<:Forecasts{T, I} -> ::Forecasts{T, I}} and payoff function: ::Forecasts{T, I} -> ::Number.","category":"page"},{"location":"postprocess/#Postprocessing","page":"Postprocessing","title":"Postprocessing","text":"","category":"section"},{"location":"postprocess/#From-point-to-probabilistic-forecasts","page":"Postprocessing","title":"From point to probabilistic forecasts","text":"","category":"section"},{"location":"postprocess/","page":"Postprocessing","title":"Postprocessing","text":"Building probabilistic forecasts from point predictions is the core functionality of PostForecasts.jl. The function point2quant turns PointForecasts into QuantForecasts, allowing to easily postprocess point predictions using a selected model, length of the training window and retraining frequency.","category":"page"},{"location":"postprocess/","page":"Postprocessing","title":"Postprocessing","text":"point2quant","category":"page"},{"location":"postprocess/#PostForecasts.point2quant","page":"Postprocessing","title":"PostForecasts.point2quant","text":"point2quant(pf, modelname, window, prob[; first, last, retrain])\n\nCompute probabilistic forecast based on point forecasts pf::PointForecasts using PostModel specified by modelname::Symbol.\n\nReturn QuantForecasts containing quantile pred at specified probabilities:\n\nprob::AbstractVector{<:AbstractFloat}: vector of probabilities\nprob::AbstractFloat: a single probability value\nprob::Integer: number of equidistant probability values (e.g. 99 for percentiles).\n\nAvailable options for modelname:\n\n:cp for conformal prediction\n:hs for historical simulation (conformal prediction with non-absolute errors)\n:idr for isotonic distributional regression\n:qr for quantile regression\n:normal for normal distribution of errors\n:zeronormal for normal distribution of errors with fixed mean equal to 0\n\nKeyword arguments:\n\nfirst::Integer = firstindex(pf) + window: specify the first index of pf for which the probabilistic forecast will be caluclated\nlast::Integer = lastindex(pf): specify the last index of pf for which the probabilistic forecast will be caluclated\nretrain::Integer = 1: specify how often to retrain the model. If retrain == 0, the model will be trained only once, otherwise it will be retrained every retrain steps\n\nNote\n\n:qr supports multiple regressors\n:idr partially supports multiple regressors: one isotonic regression is fitted to each forecast and the final predictive distribution is an average of individual distributions\n:cp, :normal and :zeronormal do not support multiple regressors: if pf contains multiple point forecasts, their average will be used for postprocessing\n\n\n\n\n\n","category":"function"},{"location":"postprocess/#Conformalizing-probabilistic-forecasts","page":"Postprocessing","title":"Conformalizing probabilistic forecasts","text":"","category":"section"},{"location":"postprocess/","page":"Postprocessing","title":"Postprocessing","text":"Apart from postprocessing point forecasts, the package offers postprocessing of probabilistic forecasts in a form of conformalization (Romano et al., 2019). Conformalizing quantiles is performed by adjusting the prediction of each quantile according to the formula hatq^(c)_tau = hatq_tau + Q_1 - tau(lambda), where Q_1 - tau(lambda) is the (1-tau)-th empirical quantile of non-conformity scores lambda_i = y_i - hatq_itau from the training window. See an example on Conformalizing weather forecasts.","category":"page"},{"location":"postprocess/","page":"Postprocessing","title":"Postprocessing","text":"conformalize\nconformalize!","category":"page"},{"location":"postprocess/#PostForecasts.conformalize","page":"Postprocessing","title":"PostForecasts.conformalize","text":"conformalize(qf::QuantForecasts{F, I}, window::Integer[; first::Integer, last::Integer)\n\nPerform conformalization of quantile forecasts provided in ps. Conformalized quantiles will be calculated for observations between the index first and last of qf. The model is retrained every step on the last window observations.\n\nReturn QuantForecasts with conformalized quantiles.\n\n\n\n\n\n","category":"function"},{"location":"postprocess/#PostForecasts.conformalize!","page":"Postprocessing","title":"PostForecasts.conformalize!","text":"conformalize!(qf::QuantForecasts{F, I}, window::Integer[; first::Integer, last::Integer)\n\nIn-place version of conformalize, that mutates qf instead of creating a new QuantForecasts.\n\n\n\n\n\n","category":"function"},{"location":"#PostForecasts.jl","page":"Home","title":"PostForecasts.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: image)","category":"page"},{"location":"#Julia-package-for-postprocessing-forecasts","page":"Home","title":"Julia package for postprocessing forecasts","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PostForecasts.jl provides structures and functions that allow to easily postprocess point forecasts into predictive distributions. Postprocessing methods use only the past performance of a given point forecasting model (or ensemble of models) to build probabilistic forecasts conditional on point predictions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"PostForecasts.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Relies on deterministic models for reliable and repeatable results\nDoes not require hyperparameter tuning\nLeverages forecaster diversity via averaging","category":"page"},{"location":"","page":"Home","title":"Home","text":"We believe that following these three principles allowed us to develop a robust tool for computing probabilistic forecasts that combines ease of use, high accuracy, fast results and good interpretability. This makes PostForecasts.jl an attractive choice for both academic and industrial applications.","category":"page"},{"location":"#Dedicated-structures","page":"Home","title":"Dedicated structures","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PostForecasts.jl introduces PointForecasts and QuantForecasts structures for storing time series data along with point and probabilistic forecasts respectively.","category":"page"},{"location":"#Variety-of-models","page":"Home","title":"Variety of models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package provides interface to four selected models for probabilistic forecasting:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Normal:  Normal error distribution\nCP: Conformal Prediction\nIDR: Isotonic Distributional Regression\nQR: Quantile Regression","category":"page"},{"location":"","page":"Home","title":"Home","text":"The models belong to the PostModel type, they have corresponding train methods for calibrating the model to the provided data and predict/predict! methods yielding quantiles of predictive distribution based on point forecast(s).","category":"page"},{"location":"#Easy-postprocessing","page":"Home","title":"Easy postprocessing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The core functionality of PostForecasts.jl is building probabilistic forecasts from point predictions. For easy postprocessing, use point2quant function to turn PointForecasts into QuantForecasts with one of the implemented models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition to methods for postprocessing point forecasts, the package provides conformalize function, allowing to correct quantile forecasts using historical errors.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install PostForecasts.jl package, enter Julia REPL and call Pkg.add:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(url = \"https://github.com/lipiecki/PostForecasts.jl\")","category":"page"},{"location":"evaluation/#Evaluation-metrics","page":"Evaluation metrics","title":"Evaluation metrics","text":"","category":"section"},{"location":"evaluation/","page":"Evaluation metrics","title":"Evaluation metrics","text":"To evaluate the peformance of both point and probabilistic forecasts, PostForecasts.jl offers methods for calculating popular evaluation metrics.","category":"page"},{"location":"evaluation/","page":"Evaluation metrics","title":"Evaluation metrics","text":"mae\nrmse\npinball\ncoverage","category":"page"},{"location":"evaluation/#PostForecasts.mae","page":"Evaluation metrics","title":"PostForecasts.mae","text":"mae(pf::PointForecasts)\n\nCalculate Mean Absolute Error of pred from pf. Return the vector of MAE corresponding to each forecaster.\n\n\n\n\n\n","category":"function"},{"location":"evaluation/#PostForecasts.rmse","page":"Evaluation metrics","title":"PostForecasts.rmse","text":"rmse(pf::PointForecasts)\n\nCalculate Root Mean Squared Error of pred from pf. Return the vector of RMSE corresponding to each forecaster.\n\n\n\n\n\n","category":"function"},{"location":"evaluation/#PostForecasts.pinball","page":"Evaluation metrics","title":"PostForecasts.pinball","text":"pinball(qf::QuantForecasts)\n\nCalculate the Pinball Loss over all quantiles in qf. Return the vector of pinball loss corresponding to each quantile. See Gneiting 2011 for more details about Pinball Loss. \n\nNote\n\nAverage pinball score over equidistant quantiles approximates Continuous Ranked Probability Score.\n\n\n\n\n\n","category":"function"},{"location":"evaluation/#PostForecasts.coverage","page":"Evaluation metrics","title":"PostForecasts.coverage","text":"coverage(qf::QuantForecasts)\n\nCalculate empirical coverage of quantile pred in qf. Return the vector of coverage corresponding to each quantile. \n\n\n\n\n\n","category":"function"}]
}
