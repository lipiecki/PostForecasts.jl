<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · PostForecasts.jl</title><meta name="title" content="Examples · PostForecasts.jl"/><meta property="og:title" content="Examples · PostForecasts.jl"/><meta property="twitter:title" content="Examples · PostForecasts.jl"/><meta name="description" content="Documentation for PostForecasts.jl."/><meta property="og:description" content="Documentation for PostForecasts.jl."/><meta property="twitter:description" content="Documentation for PostForecasts.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PostForecasts.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../forecasts/">Structures</a></li><li><a class="tocitem" href="../postprocess/">Postprocessing</a></li><li><a class="tocitem" href="../models/">Models</a></li><li><a class="tocitem" href="../loadsave/">Loading and saving forecasts</a></li><li><a class="tocitem" href="../averaging/">Averaging forecasts</a></li><li><a class="tocitem" href="../evaluation/">Evaluation metrics</a></li><li><a class="tocitem" href="../shapley/">Shapley values and ensemble contributions</a></li><li><a class="tocitem" href="../utils/">Utilities</a></li><li><a class="tocitem" href="../datasets/">Datasets</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Load-and-postprocess-point-forecasts"><span>Load and postprocess point forecasts</span></a></li><li><a class="tocitem" href="#Probabilistic-forecasting-of-day-ahead-electricity-prices"><span>Probabilistic forecasting of day-ahead electricity prices</span></a></li><li><a class="tocitem" href="#Different-flavors-of-quantile-regression"><span>Different flavors of quantile regression</span></a></li><li><a class="tocitem" href="#Conformalizing-weather-forecasts"><span>Conformalizing weather forecasts</span></a></li><li><a class="tocitem" href="#Supporting-decision-making-on-energy-markets"><span>Supporting decision making on energy markets</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/lipiecki/PostForecasts.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/lipiecki/PostForecasts.jl/blob/main/docs/src/examples.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><p>Below you can find some simple examples of what can be achieved with <strong>PostForecasts.jl</strong></p><h2 id="Load-and-postprocess-point-forecasts"><a class="docs-heading-anchor" href="#Load-and-postprocess-point-forecasts">Load and postprocess point forecasts</a><a id="Load-and-postprocess-point-forecasts-1"></a><a class="docs-heading-anchor-permalink" href="#Load-and-postprocess-point-forecasts" title="Permalink"></a></h2><p>In the first example, we show how to load point forecasts from a delimited file and postprocess them using a selected model in PostForecasts.jl. Assume that the file named <code>my-point-forecasts.csv</code> has the following structure: </p><pre><code class="language-csv hljs">timestamp,observation,forecast1,forecast2
0,52.250,53.775,52.215
1,55.005,57.450,53.732
2,58.125,57.728,58.426</code></pre><p>To load and postprocess it, we only need two function calls:</p><pre><code class="language-julia hljs">using PostForecasts
pf = loaddlm(&quot;my-point-forecasts.csv&quot;, delim=&#39;,&#39;, idcol=1, obscol=2, predcol=[3, 4], colnames=true)</code></pre><p>First, the <code>loaddlm</code> function reads the file. The arguments specify that the file is comma-delimited, the identifiers are stored in the first column, the observations in the second, and the predictions in the third and fourth. The last argument informs that the column names are present in the file, so the first row is not parsed into numeric values.</p><pre><code class="language-julia hljs">qf = point2quant(pf, method=:qr, window=100, quantiles=[0.9, 0.95, 0.99])</code></pre><p>Next, the <code>point2quant</code> function postprocesses the forecasts stored in <code>pf</code>, computes quantile predictions and stores them in <code>qf</code>. In the above snippet, the arguments specify that Quantile Regression Averaging is used for postprocessing, calibration window size is 100 data points, and that the 90th, 95th and 99th percentiles are predicted. By default, the postprocessing model is retrained before every prediction using a calibration window of most recent data points. For details on alternative configurations, see the documentation of the <a href="../postprocess/#From-point-to-probabilistic-forecasts"><code>point2quant</code></a> function.</p><p>Quantile forecasts <code>qf</code> are now ready to be <a href="../evaluation/#Evaluation-metrics">evaluated</a>, <a href="../averaging/#Forecast-Averaging">averaged</a> with other forecasts, <a href="../postprocess/#Conformalizing-probabilistic-forecasts">conformalized</a>, and <a href="../loadsave/#Loading-and-saving-forecasts">saved</a>.</p><h2 id="Probabilistic-forecasting-of-day-ahead-electricity-prices"><a class="docs-heading-anchor" href="#Probabilistic-forecasting-of-day-ahead-electricity-prices">Probabilistic forecasting of day-ahead electricity prices</a><a id="Probabilistic-forecasting-of-day-ahead-electricity-prices-1"></a><a class="docs-heading-anchor-permalink" href="#Probabilistic-forecasting-of-day-ahead-electricity-prices" title="Permalink"></a></h2><p>Let us now show how to compute probabilistic forecasts of day-ahead electricity prices from point forecasts stored in the <a href="../datasets/#EPEX">EPEX dataset</a> for all hours of the year 2023, using three different postprocessing schemes - IDR, CP and QRA. See <a href="https://doi.org/10.1016/j.eneco.2024.107934">(Lipiecki et al., 2024)</a> for more details on this forecasting task.</p><p>The snippet below first creates a dictionary that stores 24 <code>QuantForecasts</code> for each of the three models, then iterates over the 24 hours of the day, loads the point forecasts, finds the indices corresponding to the first and the last day of 2023, and generates the probabilistic forecasts for 9 deciles (i.e., percentiles 10%, 20%, ..., 90%) using each model. The results are saved in <code>QuantForecasts</code>:</p><pre><code class="language-julia hljs">using PostForecasts

methods = [:idr, :cp, :qr]
qf = Dict((m =&gt; Vector{QuantForecasts}(undef, 24) for m in methods)...)

for h in 1:24
    pf = loaddata(Symbol(:epex, h))
    for m in methods
        qf[m][h] = point2quant(pf, method=m, window=56, quantiles=9, start=20230101, stop=20231231)
    end
end</code></pre><p>The probabilistic forecasts can then be combined, e.g. using averaging over probabilities with <code>paverage</code>:</p><pre><code class="language-julia hljs">qf[:ave] = Vector{QuantForecasts}(undef, 24)
for h in 1:24
    qf[:ave][h] = paverage([qf[m][h] for m in methods])
end</code></pre><p>and the CRPS of the individual and the combined predictive distributions can be easily compared:</p><pre><code class="nohighlight hljs">println(&quot;Method \t| CRPS &quot;)
println(&quot;-&quot;^20)
for m in [methods..., :ave]
    println(uppercase(string(m)), &quot; \t| CRPS: &quot;, round(sum(crps.(qf[m]))/24, digits=3))
end</code></pre><p>which should generate the following output:</p><pre><code class="nohighlight hljs">Method 	| CRPS 
--------------------
IDR     | CRPS: 9.752
CP      | CRPS: 9.822
QR      | CRPS: 9.986
AVE     | CRPS: 9.248</code></pre><p>Note that the computations can take some time. While IDR and CP are almost instantaneous, QRA is more time-consuming and can take up to a few minutes.</p><p>The script corresponding to this example can be found in <code>examples/postprocess-epex.jl</code>.</p><h2 id="Different-flavors-of-quantile-regression"><a class="docs-heading-anchor" href="#Different-flavors-of-quantile-regression">Different flavors of quantile regression</a><a id="Different-flavors-of-quantile-regression-1"></a><a class="docs-heading-anchor-permalink" href="#Different-flavors-of-quantile-regression" title="Permalink"></a></h2><p>There are multiple approaches to applying quantile regression to a pool of point forecasts, here we compare four of them, which can be readily computed using the <strong>PostForecasts.jl</strong> package.</p><p>In this example we will postprocess day-ahead electricity price forecasts stored in the <a href="../datasets/#EPEX">EPEX dataset</a> for hour 20 during the entire year 2021, using a one-year training window:</p><pre><code class="nohighlight hljs">using PostForecasts

pf = loaddata(:epex20)
pf = pf(20200101, 20211231)
qf = Dict()</code></pre><h3 id="QRA"><a class="docs-heading-anchor" href="#QRA">QRA</a><a id="QRA-1"></a><a class="docs-heading-anchor-permalink" href="#QRA" title="Permalink"></a></h3><p><strong>Q</strong>uantile <strong>R</strong>egression <strong>A</strong>veraging - each point forecast is treated as a separate regressor in a multivariate quantile regression - <span>$\hat{q}_{\tau|\hat{y}^{(1)}, ..., \hat{y}^{(m)}} = \beta^{(\tau)}_0 + \beta^{(\tau)}_1\hat{y}^{(1)} + ... + \beta^{(\tau)}_m\hat{y}^{(m)}$</span></p><pre><code class="language-julia hljs">qf[&quot;QRA&quot;] = point2quant(pf, method=:qr, window=365, quantiles=9)</code></pre><h3 id="QRM"><a class="docs-heading-anchor" href="#QRM">QRM</a><a id="QRM-1"></a><a class="docs-heading-anchor-permalink" href="#QRM" title="Permalink"></a></h3><p><strong>Q</strong>uantile <strong>R</strong>egression <strong>M</strong>achine - point forecasts are averaged and treated as a single regressor in a univariate quantile regression - <span>$\hat{q}_{\tau|\hat{y}^{(1)}, ..., \hat{y}^{(m)}} = \beta^{(\tau)}_0 + \beta^{(\tau)}_1 \frac{1}{m}\sum_{i=1}^m{\hat{y}^{(i)}}$</span></p><pre><code class="language-julia hljs">qf[&quot;QRM&quot;] = point2quant(average(pf), method=:qr, window=365, quantiles=9)</code></pre><h3 id="QRF"><a class="docs-heading-anchor" href="#QRF">QRF</a><a id="QRF-1"></a><a class="docs-heading-anchor-permalink" href="#QRF" title="Permalink"></a></h3><p><strong>Q</strong>uantile <strong>R</strong>egression with probability (<strong>F</strong>) averaging - each point forecast is treated as a regressor of a univariate quantile regression, the output distributions of <code>m</code> quantile regressions are averaged over probabilities</p><pre><code class="language-julia hljs">qf[&quot;QRF&quot;] = paverage(point2quant.(decouple(pf), method=:qr, window=365, quantiles=9))</code></pre><h3 id="QRQ"><a class="docs-heading-anchor" href="#QRQ">QRQ</a><a id="QRQ-1"></a><a class="docs-heading-anchor-permalink" href="#QRQ" title="Permalink"></a></h3><p><strong>Q</strong>uantile <strong>R</strong>egression with <strong>Q</strong>uantile averaging - each point forecast is treated as a regressor of a univariate quantile regression, the output distributions of <code>m</code> quantile regressions are averaged over quantiles</p><pre><code class="language-julia hljs">qf[&quot;QRQ&quot;] = qaverage(point2quant.(decouple(pf), method=:qr, window=365, quantiles=9))</code></pre><p>Then we can print the resulting CRPS of the computed forecasts:</p><pre><code class="language-julia hljs">println(&quot;Method \t| CRPS &quot;)
println(&quot;-&quot;^20)
for m in [&quot;QRA&quot;, &quot;QRM&quot;, &quot;QRF&quot;, &quot;QRQ&quot;]
    println(m, &quot;\t| &quot;, round(crps(qf[m]), digits=3))
end</code></pre><p>which should yield the following output:</p><pre><code class="nohighlight hljs">Method 	| CRPS 
--------------------
QRA 	| 10.464
QRM 	| 10.229
QRF 	| 10.308
QRQ 	| 10.285</code></pre><p>The script corresponding to this example can be found in <code>examples/quantregs.jl</code>.</p><h2 id="Conformalizing-weather-forecasts"><a class="docs-heading-anchor" href="#Conformalizing-weather-forecasts">Conformalizing weather forecasts</a><a id="Conformalizing-weather-forecasts-1"></a><a class="docs-heading-anchor-permalink" href="#Conformalizing-weather-forecasts" title="Permalink"></a></h2><p>In this example we show how to conformalize quantile forecasts to improve the coverage of predictive distributions of weather variables from the <a href="../datasets/#PANGU">PANGU dataset</a> postprocessed using IDR, and visualize the miscoverage, i.e., the difference between nominal and empirical coverage, with respect to the quantile levels, using the Plots package.</p><p>We will first load the dataset (select the forecasted variable and the lead time of point predictions) and initialize the plot:</p><pre><code class="language-julia hljs">using PostForecasts, Plots

variable = :u10 # u10, c10, t2m, t850 or z500
leadtime = 24 # between 0 and 186, divisible by 6

pf = loaddata(&quot;pangu$(leadtime)$(variable)&quot;)
plot(xlabel=&quot;Quantile level (%)&quot;, ylabel=&quot;Miscoverage (%)&quot;, framestyle=:grid, xticks = 10:10:90)</code></pre><p>Then, using the <code>point2quant</code> function, we compute the quantile forecasts <code>qf</code> for 9 deciles using the IDR with a training window of 365 days and plot their miscoverage:</p><pre><code class="language-julia hljs">qf = point2quant(pf, method=:idr, window=365, quantiles=9)
bar!(getprob(qf).*100, (coverage(qf)-getprob(qf)).*100, linewidth=0, color=colorant&quot;#bcbddc&quot;, label=&quot;IDR&quot;) </code></pre><p>Next, we proceed to conformalizing <code>qf</code> and adding it to the plot:</p><pre><code class="language-julia hljs">conformalize!(qf, window=182)
bar!(getprob(qf).*100, (coverage(qf)-getprob(qf)).*100, linewidth=0, color=colorant&quot;#756bb1&quot;, label=&quot;Conformalized IDR&quot;)</code></pre><p>Note that we used the in-place method <code>conformalize!</code>, which will leave the first 182 unconformalized predictions in <code>qf</code>.</p><p>The resulting plots shows that the conformalization helped to significantly decrease the miscoverage of IDR predictions, leading to better calibrated quantile forecasts, especially at extreme levels (0.1 and 0.9): <img src="../images/conformalize-pangu.png" alt="image"/></p><p>The script corresponding to this example can be found in <code>examples/conformalize-pangu.jl</code>.</p><h2 id="Supporting-decision-making-on-energy-markets"><a class="docs-heading-anchor" href="#Supporting-decision-making-on-energy-markets">Supporting decision making on energy markets</a><a id="Supporting-decision-making-on-energy-markets-1"></a><a class="docs-heading-anchor-permalink" href="#Supporting-decision-making-on-energy-markets" title="Permalink"></a></h2><p>To highlight the significance and utility of probabilistic forecasts, let us present a short scenario of trading on day-ahead electricity market.</p><p>Consider an energy company that owns a battery and trades in the day-ahead market. Every morning it faces the decision about whether to submit a buy order to charge the battery and a sell order to discharge it at a later hour of the next day, or avoid trading due to adverse market conditions.</p><p>In this example, we show how probabilistic forecasts can help us identify risky market conditions and prevent losses.</p><p>For simplicity, we focus on two weeks in April 2023 and assume that buy orders are submitted for 3am while sell orders for 7pm. The following snippet shows how to postprocess point predictions from the EPEX dataset to obtain decile forecasts using the IDR:</p><pre><code class="language-julia hljs">using PostForecasts, Plots

fsBUY = loaddata(Symbol(:epex, 4))      # buy at 3am
fsSELL = loaddata(Symbol(:epex, 20))    # sell at 7pm

qfBUY = point2quant(fsBUY, method=:idr, window=182, quantiles=9, start=20230408, stop=20230421)
qfSELL = point2quant(fsSELL, method=:idr, window=182, quantiles=9, start=20230408, stop=20230421)</code></pre><p>From the decile forecasts we can construct four prediction intervals (PI) centered around the median with confidence level of 20%, 40%, 60% and 80%. To visualize the results, we can plot the median price forecasts, the PIs and the observed prices for 3am and 7pm:</p><pre><code class="language-julia hljs">plot(legend=:bottom, xlabel=&quot;Days&quot;, ylabel=&quot;Price (€/MWh)&quot;, xticks=1:14, framestyle=:box) 
# plot forecasts of the median price
plot!(viewpred(qfBUY, eachindex(qfBUY), 5), linealpha=0.5, color=theme_palette(:dark)[3], lw=3, label=&quot;Buy price&quot;)
plot!(viewpred(qfSELL, eachindex(qfBUY), 5), linealpha=0.5, color=theme_palette(:dark)[1], lw=3, label=&quot;Sell price&quot;)
# plot prediction intervals constructed from quantiles forecasts
for i in 1:4
    plot!(viewpred(qfBUY, eachindex(qfBUY), 5-i), lw=0, fillrange=viewpred(qfBUY, eachindex(qfBUY), 5+i), fillalpha=0.1, color=theme_palette(:dark)[3], label=nothing)
    plot!(viewpred(qfSELL, eachindex(qfBUY), 5-i), lw=0, fillrange=viewpred(qfSELL, eachindex(qfBUY), 5+i), fillalpha=0.1, color=theme_palette(:dark)[1], label=nothing)    
end
# plot observed prices
plot!(viewobs(qfBUY), color=theme_palette(:dark)[3], st=:scatter, markerstrokewidth=0, label=nothing)
plot!(viewobs(qfSELL), color=theme_palette(:dark)[1], st=:scatter, markerstrokewidth=0, label=nothing)</code></pre><p><img src="../images/trading.png" alt="image"/></p><p>Clearly, on the third day the upper quantiles of prices for 3am significantly overlap the lower quantiles of prices for 7pm. This indicates that the buy price is quite likely to be higher than the sell price, so the trading strategy carries substantial risk. Indeed, the actual price at 7pm (red dot) was lower than at 3am (green dot) for that day, so trading would lead to incurring a loss. </p><p>This short example showcases how probabilistic forecasts can provide us with more information about possible outcomes of our decisions. To read about the strategies for battery-based trading on electricity markets and their economic evaluation, see the contributions of <a href="https://doi.org/10.48550/arXiv.2308.15443">Nitka and Weron (2023)</a> and <a href="https://doi.org/10.48550/arXiv.2303.08565">Maciejowska et al. (2023)</a>.</p><p>The script corresponding to this example can be found in <code>examples/trading.jl</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../datasets/">« Datasets</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Friday 28 February 2025 10:12">Friday 28 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
