<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · PostForecasts.jl</title><meta name="title" content="Examples · PostForecasts.jl"/><meta property="og:title" content="Examples · PostForecasts.jl"/><meta property="twitter:title" content="Examples · PostForecasts.jl"/><meta name="description" content="Documentation for PostForecasts.jl."/><meta property="og:description" content="Documentation for PostForecasts.jl."/><meta property="twitter:description" content="Documentation for PostForecasts.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PostForecasts.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../forecasts/">Types</a></li><li><a class="tocitem" href="../postprocess/">Postprocessing</a></li><li><a class="tocitem" href="../models/">Models</a></li><li><a class="tocitem" href="../loadsave/">Loading and saving forecasts</a></li><li><a class="tocitem" href="../averaging/">Averaging forecasts</a></li><li><a class="tocitem" href="../evaluation/">Evaluation metrics</a></li><li><a class="tocitem" href="../shapley/">Shapley values and ensemble contributions</a></li><li><a class="tocitem" href="../utils/">Utilities</a></li><li><a class="tocitem" href="../datasets/">Datasets</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Load-and-postprocess-point-forecasts"><span>Load and postprocess point forecasts</span></a></li><li><a class="tocitem" href="#Probabilistic-forecasting-of-day-ahead-electricity-prices"><span>Probabilistic forecasting of day-ahead electricity prices</span></a></li><li><a class="tocitem" href="#Different-flavors-of-quantile-regression"><span>Different flavors of quantile regression</span></a></li><li><a class="tocitem" href="#Conformalizing-weather-forecasts"><span>Conformalizing weather forecasts</span></a></li><li><a class="tocitem" href="#Supporting-decision-making-on-energy-markets"><span>Supporting decision making on energy markets</span></a></li></ul></li><li><a class="tocitem" href="../prerelease/">Pre-release functionalities</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/lipiecki/PostForecasts.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/lipiecki/PostForecasts.jl/blob/main/docs/src/examples.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><p>Below you can find some simple examples of what can be achieved with <strong>PostForecasts.jl</strong></p><h2 id="Load-and-postprocess-point-forecasts"><a class="docs-heading-anchor" href="#Load-and-postprocess-point-forecasts">Load and postprocess point forecasts</a><a id="Load-and-postprocess-point-forecasts-1"></a><a class="docs-heading-anchor-permalink" href="#Load-and-postprocess-point-forecasts" title="Permalink"></a></h2><p>In the first example, we show how to load point forecasts from a delimited file and postprocess them using a selected model in PostForecasts.jl. Assume that the file named <code>myforecasts.csv</code> has the following structure: </p><pre><code class="language-csv hljs">time    real    predA   predB
1       110.8   118.7   116.0
2       18.0    114.1   109.2
3       71.9    82.7    75.0
...</code></pre><p>To load and postprocess it, we only need two function calls:</p><pre><code class="language-julia hljs">using PostForecasts
pf = loaddlm(&quot;myforecasts.csv&quot;, delim=&#39;\t&#39;, idcol=1, obscol=2, predcol = [3, 4], colnames=true)</code></pre><p>First, we read the file with the <code>loaddlm</code> function, which arguments specify that the file is tab delimited, the identifiers are stored in the first column, the observations in the second, and the predictions in the third and fourth. The last argument informs that the column names are present in the file, so the first row is not parsed into numeric values.</p><pre><code class="language-julia hljs">qf = point2quant(pf, method=:qr, window=100, quantiles=[0.5, 0.9])</code></pre><p>Next, the <code>point2quant</code> function postprocesses the forecasts stored in <code>pf</code>, computes quantile predictions and returns a <code>QuantForecasts</code> object, saved to <code>qf</code>. In the above snippet, the arguments of <code>point2quant</code> specify that quantile regression is used for postprocessing, the length of the calibration window is 100 data points, and that we want to predict the median and the 90th percentile. By default, the postprocessing model is retrained before every prediction using a calibration window of most recent data points. For details on alternative configurations, see the documentation of the <a href="../postprocess/#From-point-to-probabilistic-forecasts"><code>point2quant</code></a> function.</p><p>Quantile forecasts <code>qf</code> are now ready to be <a href="../evaluation/#Evaluation-metrics">evaluated</a>, <a href="../averaging/#Forecast-Averaging">averaged</a> with other forecasts, <a href="../postprocess/#Conformalizing-probabilistic-forecasts">conformalized</a>, and <a href="../loadsave/#Loading-and-saving-forecasts">saved</a>.</p><h2 id="Probabilistic-forecasting-of-day-ahead-electricity-prices"><a class="docs-heading-anchor" href="#Probabilistic-forecasting-of-day-ahead-electricity-prices">Probabilistic forecasting of day-ahead electricity prices</a><a id="Probabilistic-forecasting-of-day-ahead-electricity-prices-1"></a><a class="docs-heading-anchor-permalink" href="#Probabilistic-forecasting-of-day-ahead-electricity-prices" title="Permalink"></a></h2><p>In this example we show how to compute probabilistic forecasts of day-ahead electricity prices from point forecasts stored in the <a href="../datasets/#EPEX">EPEX dataset</a> for all hours of the year 2023, using three different postprocessing schemes – IDR, CP and QRA. See <a href="https://doi.org/10.1016/j.eneco.2024.107934">(Lipiecki et al., 2024)</a> for more details on this forecasting task.</p><p>The code snippet below first creates a dictionary <code>qf</code> that for each key (corresponding to the postprocessing method) will store a vector of 24 <code>QuantForecasts</code> objects. Then it iterates over the 24 hours of the day, loads the point forecasts and, using each method, generates the probabilistic forecasts of 9 deciles (i.e. 10%, 20%, ..., 90% percentiles) for 2023:</p><pre><code class="language-julia hljs">using PostForecasts

methods = [:idr, :cp, :qr]
qf = Dict((m =&gt; Vector{QuantForecasts}(undef, 24) for m in methods)...)

for h in 1:24
    pf = loaddata(Symbol(:epex, h))
    for m in methods
        qf[m][h] = point2quant(pf, method=m, window=56, quantiles=9, start=20230101, stop=20231231)
    end
end</code></pre><p>Probabilistic forecasts can then be combined, e.g., using vertical distribution averaging by calling <code>paverage</code>:</p><pre><code class="language-julia hljs">qf[:ave] = Vector{QuantForecasts}(undef, 24)
for h in 1:24
    qf[:ave][h] = paverage([qf[m][h] for m in methods])
end</code></pre><p>and the CRPS of the individual and the combined predictive distributions can be easily compared:</p><pre><code class="nohighlight hljs">println(&quot;Method \t| CRPS &quot;)
println(&quot;-&quot;^20)
for m in [methods..., :ave]
    println(uppercase(string(m)), &quot; \t| CRPS: &quot;, round(sum(crps.(qf[m]))/24, digits=3))
end</code></pre><p>which should generate the following output:</p><pre><code class="nohighlight hljs">Method 	| CRPS 
--------------------
IDR     | CRPS: 9.752
CP      | CRPS: 9.822
QR      | CRPS: 9.986
AVE     | CRPS: 9.248</code></pre><p>Note that the computations can take some time. While IDR and CP are almost instantaneous, QR is more time-consuming and can take up to a few minutes.</p><p>The script corresponding to this example can be found in <code>examples/postprocess.jl</code>.</p><h2 id="Different-flavors-of-quantile-regression"><a class="docs-heading-anchor" href="#Different-flavors-of-quantile-regression">Different flavors of quantile regression</a><a id="Different-flavors-of-quantile-regression-1"></a><a class="docs-heading-anchor-permalink" href="#Different-flavors-of-quantile-regression" title="Permalink"></a></h2><p>There are multiple approaches to applying quantile regression to a pool of point forecasts, here we compare four of them, which can be readily computed using the <strong>PostForecasts.jl</strong> package.</p><p>The code below shows how to compute probabilistic forecasts of day-ahead electricity prices at 7pm for the entire 2021 from point forecasts stored in the <a href="../datasets/#EPEX">EPEX dataset</a>, using four variants of quantile regression and a one-year training window.</p><pre><code class="nohighlight hljs">using PostForecasts

pf = loaddata(:epex20)
pf = pf(20200101, 20211231)
qf = Dict()</code></pre><h3 id="QRA"><a class="docs-heading-anchor" href="#QRA">QRA</a><a id="QRA-1"></a><a class="docs-heading-anchor-permalink" href="#QRA" title="Permalink"></a></h3><p><strong>Q</strong>uantile <strong>R</strong>egression <strong>A</strong>veraging - each point forecast is treated as a separate regressor in a multivariate quantile regression - <span>$\hat{q}_{\tau|\hat{y}^{(1)}, ..., \hat{y}^{(m)}} = \beta^{(\tau)}_0 + \beta^{(\tau)}_1\hat{y}^{(1)} + ... + \beta^{(\tau)}_m\hat{y}^{(m)}$</span></p><pre><code class="language-julia hljs">qf[&quot;QRA&quot;] = point2quant(pf, method=:qr, window=365, quantiles=9)</code></pre><h3 id="QRM"><a class="docs-heading-anchor" href="#QRM">QRM</a><a id="QRM-1"></a><a class="docs-heading-anchor-permalink" href="#QRM" title="Permalink"></a></h3><p><strong>Q</strong>uantile <strong>R</strong>egression <strong>M</strong>achine - point forecasts are averaged and treated as a single regressor in a univariate quantile regression - <span>$\hat{q}_{\tau|\hat{y}^{(1)}, ..., \hat{y}^{(m)}} = \beta^{(\tau)}_0 + \beta^{(\tau)}_1 \frac{1}{m}\sum_{i=1}^m{\hat{y}^{(i)}}$</span></p><pre><code class="language-julia hljs">qf[&quot;QRM&quot;] = point2quant(average(pf), method=:qr, window=365, quantiles=9)</code></pre><h3 id="QRF"><a class="docs-heading-anchor" href="#QRF">QRF</a><a id="QRF-1"></a><a class="docs-heading-anchor-permalink" href="#QRF" title="Permalink"></a></h3><p><strong>Q</strong>uantile <strong>R</strong>egression with probability (<strong>F</strong>) averaging - each point forecast is treated as a regressor of a univariate quantile regression, the output distributions of <code>m</code> quantile regressions are averaged over probabilities</p><pre><code class="language-julia hljs">qf[&quot;QRF&quot;] = paverage(point2quant.(decouple(pf), method=:qr, window=365, quantiles=9))</code></pre><h3 id="QRQ"><a class="docs-heading-anchor" href="#QRQ">QRQ</a><a id="QRQ-1"></a><a class="docs-heading-anchor-permalink" href="#QRQ" title="Permalink"></a></h3><p><strong>Q</strong>uantile <strong>R</strong>egression with <strong>Q</strong>uantile averaging - each point forecast is treated as a regressor of a univariate quantile regression, the output distributions of <code>m</code> quantile regressions are averaged over quantiles</p><pre><code class="language-julia hljs">qf[&quot;QRQ&quot;] = qaverage(point2quant.(decouple(pf), method=:qr, window=365, quantiles=9))</code></pre><p>Then we can print the resulting CRPS of the computed forecasts:</p><pre><code class="language-julia hljs">println(&quot;Method \t| CRPS &quot;)
println(&quot;-&quot;^20)
for m in [&quot;QRA&quot;, &quot;QRM&quot;, &quot;QRF&quot;, &quot;QRQ&quot;]
    println(m, &quot;\t| &quot;, round(crps(qf[m]), digits=3))
end</code></pre><p>which should generate the following output:</p><pre><code class="nohighlight hljs">Method 	| CRPS 
--------------------
QRA 	| 10.464
QRM 	| 10.229
QRF 	| 10.308
QRQ 	| 10.285</code></pre><p>The script corresponding to this example can be found in <code>examples/quantregs.jl</code>.</p><h2 id="Conformalizing-weather-forecasts"><a class="docs-heading-anchor" href="#Conformalizing-weather-forecasts">Conformalizing weather forecasts</a><a id="Conformalizing-weather-forecasts-1"></a><a class="docs-heading-anchor-permalink" href="#Conformalizing-weather-forecasts" title="Permalink"></a></h2><p>In this example we show how to conformalize quantile forecasts to improve the coverage of predictive distributions of weather variables from the <a href="../datasets/#PANGU">PANGU dataset</a> postprocessed using IDR, and visualize the miscoverage, i.e., the difference between nominal and empirical coverage, with respect to the quantile levels.</p><p>We will first load the dataset (select the target variable and the lead time of point predictions):</p><pre><code class="language-julia hljs">using PostForecasts

variable = :u10 # u10, c10, t2m, t850 or z500
leadtime = 24   # between 0 and 186, divisible by 6

pf = loaddata(Symbol(:pangu, leadtime, variable))</code></pre><p>Then, using the <code>point2quant</code> function, we compute the quantile forecasts <code>qf</code> for 9 deciles using IDR with a training window of 365 days and calculate its miscoverage with the help of the <code>coverage</code> function:</p><pre><code class="language-julia hljs">qf = point2quant(pf, method=:idr, window=364, quantiles=9)
miscoverageIDR = (coverage(qf) - getprob(qf)).*100</code></pre><p>Now, we can conformalize forecasts stored in <code>qf</code> and calculate the miscoverage of conformalized quantiles:</p><pre><code class="language-julia hljs">conformalize!(qf, window=182)
miscoverageConformalizedIDR = (coverage(qf) - getprob(qf)).*100</code></pre><p>Note that we used the in-place method <code>conformalize!</code>, which will leave the first 182 unconformalized predictions in <code>qf</code>, ensuring that the we compare the results on the same time period.</p><p>Finally, we generate a barplot representing the miscoverage for every forecasted quantile level:</p><pre><code class="language-julia hljs">using Plots
plot(xlabel=&quot;Quantile level (%)&quot;, ylabel=&quot;Miscoverage (%)&quot;, framestyle=:grid, xticks = 10:10:90)

qf = point2quant(pf, method=:idr, window=365, quantiles=9)
bar!(getprob(qf).*100, (coverage(qf)-getprob(qf)).*100, linewidth=0, color=colorant&quot;#bcbddc&quot;, label=&quot;IDR&quot;) 

conformalize!(qf, window=182)
bar!(getprob(qf).*100, (coverage(qf)-getprob(qf)).*100, linewidth=0, color=colorant&quot;#756bb1&quot;, label=&quot;Conformalized IDR&quot;)</code></pre><p>The resulting plots shows that the conformalization helped to significantly decrease the miscoverage of IDR predictions, leading to better calibrated quantile forecasts, especially at extreme levels (0.1 and 0.9): <img src="../images/conformalize.png" alt="image"/></p><p>The script corresponding to this example can be found in <code>examples/conformalize.jl</code>.</p><h2 id="Supporting-decision-making-on-energy-markets"><a class="docs-heading-anchor" href="#Supporting-decision-making-on-energy-markets">Supporting decision making on energy markets</a><a id="Supporting-decision-making-on-energy-markets-1"></a><a class="docs-heading-anchor-permalink" href="#Supporting-decision-making-on-energy-markets" title="Permalink"></a></h2><p>To highlight the significance and utility of probabilistic forecasts, let us present a short scenario of trading on day-ahead electricity market.</p><p>Consider an energy company that owns a battery and trades in the day-ahead market. Every morning it faces the decision about whether to submit a buy order to charge the battery and a sell order to discharge it at a later hour of the next day, or avoid trading due to adverse market conditions. In this example, we show how probabilistic forecasts can help us identify risky market conditions and prevent losses.</p><p>For simplicity, we focus on two weeks in April 2023 and assume that buy orders are submitted at 3am while sell orders at 7pm. The following snippet shows how to postprocess point predictions from the EPEX dataset to obtain decile forecasts using the IDR:</p><pre><code class="language-julia hljs">using PostForecasts

pfbuy = loaddata(Symbol(:epex, 4))      # point forecasts for 3am
pfsell = loaddata(Symbol(:epex, 20))    # point forecasts for 7pm

qfbuy = point2quant(pfbuy, method=:idr, window=182, quantiles=9, start=20230408, stop=20230421)
qfsell = point2quant(pfsell, method=:idr, window=182, quantiles=9, start=20230408, stop=20230421)</code></pre><p>From the decile forecasts we can construct four prediction intervals (PI) centered around the median, i.e., the 5th decile, with confidence levels of 20%, 40%, 60% and 80%. For example, the 20%-PI is obtained by taking the 4th and the 6th deciles, while the 80%-PI by taking the 1st and the 9th. To visualize the results, we can plot the median price forecasts, the PIs and the observed prices at 3am and 7pm (helper functions for plotting are available in <code>src/examples/plotting.jl</code>):</p><pre><code class="language-julia hljs"># load plot_obs!, plot_quantile! and plot_intervals!
include(&quot;plotting.jl&quot;)

pfbuy = loaddata(Symbol(:epex, 4))      # point forecasts for 3am
pfsell = loaddata(Symbol(:epex, 20))    # point forecasts for 7pm

qfbuy = point2quant(pfbuy, method=:idr, window=182, quantiles=9, start=20230408, stop=20230421)
qfsell = point2quant(pfsell, method=:idr, window=182, quantiles=9, start=20230408, stop=20230421)

plt = plot(legend=:bottom, xlabel=&quot;Days&quot;, ylabel=&quot;Price (EUR/MWh)&quot;, xticks=1:14, framestyle=:box) 
plot_intervals!(plt, qfsell, color=1)
plot_intervals!(plt, qfbuy, color=3)
plot_quantile!(plt, qfsell, 5, color=1)
plot_quantile!(plt, qfbuy, 5, color=3)
plot_obs!(plt, qfsell, color=1, label=&quot;Sell price&quot;)
plot_obs!(plt, qfbuy, color=3, label=&quot;Buy price&quot;)</code></pre><p><img src="../images/trading.png" alt="image"/></p><p>Clearly, on the third day the upper quantiles of prices for 3am significantly overlap the lower quantiles of prices for 7pm. This indicates that the buy price is quite likely to be higher than the sell price, so the trading strategy carries substantial risk. Indeed, the actual price at 7pm (<span>$\rightarrow$</span> red dot) was lower than at 3am (<span>$\rightarrow$</span> green dot) for that day, so trading would lead to incurring a loss. </p><p>This short example showcases how probabilistic forecasts can aid decision making with richer information about possible outcomes. To read about the strategies for battery-based trading on electricity markets and their economic evaluation, see the contributions of <a href="https://doi.org/10.48550/arXiv.2308.15443">Nitka and Weron (2023)</a> and <a href="https://doi.org/10.48550/arXiv.2303.08565">Maciejowska et al. (2023)</a>.</p><p>The script corresponding to this example can be found in <code>examples/trading.jl</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../datasets/">« Datasets</a><a class="docs-footer-nextpage" href="../prerelease/">Pre-release functionalities »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 21 July 2025 06:57">Monday 21 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
