<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · PostForecasts.jl</title><meta name="title" content="Examples · PostForecasts.jl"/><meta property="og:title" content="Examples · PostForecasts.jl"/><meta property="twitter:title" content="Examples · PostForecasts.jl"/><meta name="description" content="Documentation for PostForecasts.jl."/><meta property="og:description" content="Documentation for PostForecasts.jl."/><meta property="twitter:description" content="Documentation for PostForecasts.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PostForecasts.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../forecasts/">Structures</a></li><li><a class="tocitem" href="../models/">Models</a></li><li><a class="tocitem" href="../postprocess/">Postprocessing</a></li><li><a class="tocitem" href="../loadsave/">Loading and saving forecasts</a></li><li><a class="tocitem" href="../averaging/">Averaging forecasts</a></li><li><a class="tocitem" href="../evaluation/">Evaluation metrics</a></li><li><a class="tocitem" href="../shapley/">Shapley values and ensemble contributions</a></li><li><a class="tocitem" href="../utils/">Utilities</a></li><li><a class="tocitem" href="../datasets/">Datasets</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Load-and-postprocess-point-forecasts"><span>Load and postprocess point forecasts</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/lipiecki/PostForecasts.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/lipiecki/PostForecasts.jl/blob/main/docs/src/examples.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><p>Below You can find some simple examples of what can be achieved with <code>PostForecasts.jl</code></p><h2 id="Load-and-postprocess-point-forecasts"><a class="docs-heading-anchor" href="#Load-and-postprocess-point-forecasts">Load and postprocess point forecasts</a><a id="Load-and-postprocess-point-forecasts-1"></a><a class="docs-heading-anchor-permalink" href="#Load-and-postprocess-point-forecasts" title="Permalink"></a></h2><p>In this short example we will show how to load Your own point forecasts and postprocess them using a selected model.</p><p>First, we will load the package:</p><pre><code class="language-julia hljs">
using PostForecasts</code></pre><p>Then specify the path where the delimitted file with point forecasts is located, for example:</p><pre><code class="language-julia hljs">filepath = &quot;my-data/my-point-forecasts.csv&quot;</code></pre><p>We can load this file using <code>loaddlmdata()</code> function, but we first need to know the structure of the data. For the sake of example we will assume the following scheme of the <code>my-point-forecasts.csv</code> file:</p><pre><code class="language-csv hljs">date,observation,forecast1,forecast2
0101,53,55,50
0102,52,54,56
0103,60,58,59
...
Now we can laod it to the variable `pf` with:</code></pre><p>julia pf = loaddlmdata(filepath, delim=&#39;,&#39;, idcol=1, obscol=2, predcol=[3, 4], colnames=true)</p><pre><code class="nohighlight hljs">the arguments specify that the file is delimitted with a comma, the identifiers are stored in the first column, the observations in the second, and the predicitons in the third and fourth one. Additionally, `colnames=true` informs that the column names are present, so the first row will not be parsed into numeric values.

Finally, we can proceed to postprocessing the forecasts and generating predictive distributions. For this we will need to specify the `quantiles` of interest, the length of the training `window`, and the `model`. For example:</code></pre><p>julia model = :qr window = 100 quantiles = [0.9, 0.95, 0.99]</p><pre><code class="nohighlight hljs">will calibrate quantile regression on the window of 100 data points to forecast the 90-th, 95-th and 99-th percentile. Running</code></pre><p>julia qf = point2quant(pf, model, window, quantiles)</p><pre><code class="nohighlight hljs">will generate the series of quantile forecasts `qf` starting from the `window+1`-th point in the series of point forecasts `pf`. By default, the model is retrained before every prediction using the most recent `window` points. To train the model only once, on the first `window` points in the series, you can use the keyword argument `retrain=0`.

Quantile forecasts `qf` are now ready to be [evaluated](evaluation.md#Evaluation-metrics), [averaged](averaging.md#Forecast-Averaging) with other forecasts, [conformalized](postprocess.md#Conformalizing-probabilistic-forecasts) and [saved](loadsave.md#Loading-and-saving-forecasts).

## Electricity price forecasting
This example showcases how to prepare probabilistic forecasts of day-ahead electricity prices for all 24 hours of the day within a full calendar year, using three different models (IDR, CP and QRA). See [(Lipiecki et al., 2024)](https://doi.org/10.1016/j.eneco.2024.107934) for more details on this forecasting task.

First, specify the year (between 2020 and 2023) and the length of the training window (note that the data starts on December 27, 2018). Here we use the year 2021 and a 182-day window.</code></pre><p>julia using PostForecasts, Statistics</p><p>year = 2021 window = 182 models = [:idr, :cp, :qr]</p><pre><code class="nohighlight hljs">Prepare a dictionary for storing pinball loss values for each model and hour.</code></pre><p>julia losses = Dict((model =&gt; zeros(24) for model in models)...)</p><pre><code class="nohighlight hljs">Then, for each hour load the point forecasts to the variable `pf` and find the indices corresponidng to the first and last day of the specified year. Generate the probabilistic forecasts for 9 deciles (`nquantiles = 9`) using each model and save their corresponding mean pinball loss to the dictionary.</code></pre><p>julia Threads.@threads for hour in 1:24     pf = loaddata(Symbol(:epex, hour))     first = findindex(pf, year<em>10_000 + 0101)     last = findindex(pf, year</em>10_000 + 1231)     nquantiles = 9     for model in models         losses[model][hour] = mean(pinball(point2quant(pf, model, window, nquantiles, first=first, last=last)))     end end</p><pre><code class="nohighlight hljs">Here, `Threads.@threads` is used to parallelize over available threads. Use `julia --threads=X` to run a Julia instance with `X` threads. Finally, we can proceed to printing the results.</code></pre><p>julia println(&quot;Year: year&quot;) println(&quot;Calibration window of window days&quot;) println(&quot;-&quot;^30) println(&quot;Model\t| Average Pinball Loss&quot;) println(&quot;-&quot;^30) for model in models     println(uppercase(string(model)), &quot;\t|&quot;, round(mean(losses[model]), digits=3)) end println(&quot;-&quot;^30)</p><pre><code class="nohighlight hljs">
This script (`examples/epf.jl`) should yield the following output:</code></pre><p>Year: 2021 Calibration window of 182 days ––––––––––––––– Model	| Average Pinball Loss ––––––––––––––– IDR	|4.831 CP	|4.859 QR	|4.768 –––––––––––––––</p><pre><code class="nohighlight hljs">Note that the computation may take some time. While IDR and CP are almost instantaneous, QRA is more time-consuming and can take several minutes if run on a single thread.

## Different flavors of quantile regression
There are multiple approaches to applying quantile regression to a pool of point forecasts, here we compare four of them, which can be readily computed using the **PostForecasts.jl** package.

First, specify the training window, the number of quantiles to be forecasted and the data to be used for postprocessing:
</code></pre><p>using PostForecasts</p><p>year = 2021 window = 182 nquantiles = 9 hour = 15</p><p>pf = loaddata(Symbol(:epex, hour)) first = findindex(pf, year<em>10_000 + 0101) last = findindex(pf, year</em>10_000 + 1231) pf = pf[first-window:last]</p><pre><code class="nohighlight hljs">
### QRA
**Q**uantile **R**egression **A**veraging - each point forecast is treated as a seperate regressor in a multivariate quantile regression - $\hat{q}_{\tau|\hat{y}^{(1)}, ..., \hat{y}^{(m)}} = \beta^{(\tau)}_0 + \beta^{(\tau)}_1\hat{y}^{(1)} + ... + \beta^{(\tau)}_m\hat{y}^{(m)}$</code></pre><p>julia qfQRA = point2quant(pf, :qr, window, nquantiles)</p><pre><code class="nohighlight hljs">
### QRM
**Q**uantile **R**egression **M**achine - point forecasts are averaged and treated as a single regressor in a univariate quantile regression - $\hat{q}_{\tau|\hat{y}^{(1)}, ..., \hat{y}^{(m)}} = \beta^{(\tau)}_0 + \beta^{(\tau)}_1 \frac{1}{m}\sum_{i=1}^m{\hat{y}^{(i)}}$</code></pre><p>julia qfQRM = point2quant(average(pf), :qr, window, nquantiles)</p><pre><code class="nohighlight hljs">
### QRF
**Q**uantile **R**egression with probability (**F**) averaging - each point forecast is treated as a regressor of a univariate quantile regression, the output distributions of `m` quantile regressions are averaged over probabilities</code></pre><p>julia qfQRF = paverage([point2quant(ipf, :qr, window, nquantiles) for ipf in decouple(pf)], nquantiles)</p><pre><code class="nohighlight hljs">
### QRQ
**Q**uantile **R**egression with **Q**uantile averaging - each point forecast is treated as a regressor of a univariate quantile regression, the output distributions of `m` quantile regressions are averaged over quantiles</code></pre><p>julia qfQRQ = qaverage([point2quant(ipf, :qr, window, nquantiles) for ipf in decouple(pf)])</p><pre><code class="nohighlight hljs">Then we can print the results of the computed models.</code></pre><p>julia println(&quot;Year year, hour hour - 1:00&quot;) println(&quot;Calibration window of window days&quot;) println(&quot;-&quot;^30) println(&quot;Model\t| Average Pinball Loss&quot;) println(&quot;-&quot;^30) println(&quot;QRA\t|&quot;, round(mean(pinball(qfQRA)), digits=3)) println(&quot;QRM\t|&quot;, round(mean(pinball(qfQRM)), digits=3)) println(&quot;QRF\t|&quot;, round(mean(pinball(qfQRQ)), digits=3)) println(&quot;QRQ\t|&quot;, round(mean(pinball(qfQRF)), digits=3)) println(&quot;-&quot;^30)</p><pre><code class="nohighlight hljs">The expected output of this script (`examples/quantregs.jl`):</code></pre><p>Year 2021, hour 14:00 Calibration window of 182 days ––––––––––––––– Model	| Average Pinball Loss ––––––––––––––– QRA	|5.61 QRM	|5.449 QRF	|5.296 QRQ	|5.365 –––––––––––––––</p><pre><code class="nohighlight hljs">
## Conformalizing weather forecasts
Specify which weather variable to forecast and at which lead time to use.</code></pre><p>julia using PostForecasts</p><p>variable = :u10 # u10, c10, t2m, t850 or z500 leadtime = 24 # between 0 and 186, divisible by 6</p><p>pf = loaddata(Symbol(:pangu, leadtime, variable)) println(&quot;uppercase(string(variable)) forecasts with lead time of leadtime hours&quot;)</p><pre><code class="nohighlight hljs">Compute the quantile forecasts for 9 deciles using IDR with a training window of a single year.</code></pre><p>julia qf = point2quant(fs, :idr, 364, 9)</p><pre><code class="nohighlight hljs">Then print the coverage of `qf`.</code></pre><p>julia println(&quot;\t&quot;, &quot;-&quot;^73) println(&quot;\t| \t\t\t Coverage of α-quantiles \t\t\t|&quot;) println(&quot;-&quot;^81) println(&quot;Model\t| α=0.1\t| α=0.2\t| α=0.3\t| α=0.4\t| α=0.5\t| α=0.6\t| α=0.7\t| α=0.8\t| α=0.9\t|&quot;) println(&quot;-&quot;^81) print(&quot;IDR\t|&quot;) for cov in coverage(qf)     print(&quot; &quot;, round(cov, digits=3), &quot;\t|&quot;) end println()</p><pre><code class="nohighlight hljs">
Conformalize the quanitle forecasts `qf`, with 182-day training window. Note that the in-place method `confomalize!` will leave the first 182 unmodified predictions in the `qf`. </code></pre><p>julia conformalize!(qf, 182)</p><pre><code class="nohighlight hljs">Now we can print the coverage of `qf` after conformalization.</code></pre><p>julia println(&quot;-&quot;^81) print(&quot;CIDR\t|&quot;) for cov in coverage(qf)     print(&quot; &quot;, round(cov, digits=3), &quot;\t|&quot;) end println() println(&quot;-&quot;^81)</p><pre><code class="nohighlight hljs">This script (`examples/weather.jl`) should produce the following output:</code></pre><p>U10 forecasts with lead time of 24 hours         ––––––––––––––––––––––––––––––––––––-         |                        Coverage of α-quantiles                        | ––––––––––––––––––––––––––––––––––––––––- Model   | α=0.1 | α=0.2 | α=0.3 | α=0.4 | α=0.5 | α=0.6 | α=0.7 | α=0.8 | α=0.9 | ––––––––––––––––––––––––––––––––––––––––- IDR     | 0.157 | 0.238 | 0.322 | 0.42  | 0.493 | 0.59  | 0.681 | 0.762 | 0.85  | ––––––––––––––––––––––––––––––––––––––––- CIDR    | 0.106 | 0.204 | 0.309 | 0.411 | 0.501 | 0.596 | 0.71  | 0.795 | 0.897 | ––––––––––––––––––––––––––––––––––––––––-</p><pre><code class="nohighlight hljs">which shows that the conformalization indeed helps to decrease the miscoverage of IDR predictions, especially at more extreme quantiles (0.1 and 0.9).

## Supporting decision making on energy markets
To highlight the significance and utility of probabilsitic forecasts, let us present a short scenario of trading on day-ahead electricity market.

Imagine that we have battery at our disposal, and for simplicity assume that each day we can buy and sell energy only at specifc hours, e.g. buy at 3:00 and sell at 19:00 (trading hours from a strategy used by [Marcjasz et al. (2023)](https://doi.org/10.1016/j.eneco.2023.106843)). Therefore, everyday we face the decision about whether to submit buy and sell orders for the next day, or avoid trading. Forecasts of day-ahead prices can support this decision-making process.

As an example, we will focus on two weeks in April 2023. Firstly, we will postprocess point predictions to obtain quantile forecasts using IDR</code></pre><p>julia using PostForecasts, Plots</p><p>firstdate = 20230408 lastdate = 20230421</p><p>buyhour = 4     # 3:00 sellhour = 20   # 19:00</p><p>fsBUY = loaddata(Symbol(:epex, buyhour)) fsSELL = loaddata(Symbol(:epex, sellhour))</p><p>first= findindex(fsBUY, firstdate) last = findindex(fsBUY, lastdate)</p><p>qfBUY = point2quant(fsBUY, :idr, 182, 9, first=first, last=last) qfSELL = point2quant(fsSELL, :idr, 182, 9, first=first, last=last)</p><pre><code class="nohighlight hljs">Let us see what we can learn from the forecasts of median price:</code></pre><p>julia theme(:dark) plot(legend = :bottom, xlabel = &quot;Days&quot;, ylabel = &quot;Price (€/MWh)&quot;, xticks = 1:14, framestyle = :box) plot!(viewpred(qfBUY, eachindex(qfBUY), 5), linealpha = 0.5, color=3, lw=3, label=&quot;Buy hour (<span>$(buyhour):00)&quot;) plot!(viewpred(qfSELL, eachindex(qfBUY), 5), linealpha = 0.5, color=1, lw=3, label=&quot;Sell hour ($</span>(sellhour):00)&quot;)</p><pre><code class="nohighlight hljs">![image](images/trading1.png)
Analyzing the above plot, every day seems to be profitable, but the information is quite limited. To make an informed decision, we would like to see what can happens in more extreme scenarios. Since we computed 9 deciles, we can plot 4 prediction intervals centered around the median (with confidence of 20%, 40%, 60% and 80%):</code></pre><p>julia for i in 1:4     plot!(viewpred(qfBUY, eachindex(qfBUY), 5-i), lw = 0, fillrange = viewpred(qfBUY, eachindex(qfBUY), 5+i), fillalpha = 0.1, color = 3, label = nothing)     plot!(viewpred(qfSELL, eachindex(qfBUY), 5-i), lw = 0, fillrange = viewpred(qfSELL, eachindex(qfBUY), 5+i), fillalpha = 0.1, color = 1, label = nothing)     end</p><pre><code class="nohighlight hljs">![image](images/trading2.png)
Now we see that on the 3rd day, the upper quantiles of prices at 3:00 significantly overlap the lower quantiles of prices at 19:00. Depending on our risk appetite, we could refrain from trading during this day to avoid possible losses.

Finally, let&#39;s add the observed prices during this period:</code></pre><p>julia plot!(viewobs(qfBUY), color = 3, st=:scatter, markerstrokewidth=0, label=nothing) plot!(viewobs(qfSELL), color = 1, st=:scatter, markerstrokewidth=0, label=nothing) ``` <img src="../images/trading3.png" alt="image"/> Indeed, on the 3rd day the decision to avoid traiding would prevent us from incurring a loss. </p><p>This short example was cherry-picked to showcase how probabilistic foreecasts provide us with more information about possible outcomes of decisions. To read about the strategies for battery-based trading on electricity markets and their economic evaluation, see the contributions of <a href="https://doi.org/10.48550/arXiv.2308.15443">Nitka and Weron (2023)</a> and <a href="https://doi.org/10.48550/arXiv.2303.08565">Maciejowska et al. (2023)</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../datasets/">« Datasets</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Saturday 21 December 2024 08:57">Saturday 21 December 2024</span>. Using Julia version 1.10.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
